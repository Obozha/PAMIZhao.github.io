<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++读写文件操作</title>
      <link href="/2021/03/01/cppio/"/>
      <url>/2021/03/01/cppio/</url>
      
        <content type="html"><![CDATA[<h2 id="fstream三个类"><a href="#fstream三个类" class="headerlink" title="fstream三个类"></a>fstream三个类</h2><p>fstream提供了三个类，用来实现c++对文件的操作（文件的创建、读、写）</p><ul><li>ifstream - 从已有的文件读入</li><li>ofstream - 向文件写内容</li><li>fstream  - 打开文件供读写</li></ul><h2 id="文件打开模式"><a href="#文件打开模式" class="headerlink" title="文件打开模式"></a>文件打开模式</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研上机代码</title>
      <link href="/2021/03/01/hedacode/"/>
      <url>/2021/03/01/hedacode/</url>
      
        <content type="html"><![CDATA[<h2 id="ascii图片"><a href="#ascii图片" class="headerlink" title="ascii图片"></a>ascii图片</h2><h2 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">encode</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>result<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token punctuation">(</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">"+"</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" result:"</span><span class="token operator">&lt;&lt;</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">"+"</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" result:"</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token number">122</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">122</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    result<span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'\0'</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">decode</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>result<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token number">-1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token punctuation">(</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token operator">=</span><span class="token number">122</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    result<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'\0'</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="n到m的素数"><a href="#n到m的素数" class="headerlink" title="n到m的素数"></a>n到m的素数</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">isPrime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">testPrime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> m<span class="token punctuation">,</span>n<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入m、n:"</span><span class="token punctuation">;</span>    cin<span class="token operator">&gt;&gt;</span>m<span class="token operator">&gt;&gt;</span>n<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"m到n之间的素数有："</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>m<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>m<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isPrime</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            cout<span class="token operator">&lt;&lt;</span> m<span class="token operator">&lt;&lt;</span><span class="token string">"是素数"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="分开字符与数字"><a href="#分开字符与数字" class="headerlink" title="分开字符与数字"></a>分开字符与数字</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">testStr2SubStr</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">;</span>    len<span class="token operator">=</span><span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token operator">*</span> num<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token operator">*</span> character<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token number">47</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">58</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>str<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            character<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>str<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'\0'</span><span class="token punctuation">;</span>    character<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'\0'</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>num<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>character<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="两字符交换"><a href="#两字符交换" class="headerlink" title="两字符交换"></a>两字符交换</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">testSwapChar</span><span class="token punctuation">(</span><span class="token keyword">int</span> q<span class="token punctuation">,</span><span class="token keyword">int</span> p<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"old str:"</span><span class="token operator">&lt;&lt;</span>str<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">int</span> len<span class="token operator">=</span><span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>nStr<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>nStr<span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> temp<span class="token operator">=</span>nStr<span class="token punctuation">[</span>q<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    nStr<span class="token punctuation">[</span>q<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">=</span>nStr<span class="token punctuation">[</span>p<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    nStr<span class="token punctuation">[</span>p<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"new str:"</span><span class="token operator">&lt;&lt;</span>nStr<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研究生复试问题QA</title>
      <link href="/2021/02/24/graduatestudentretestqa/"/>
      <url>/2021/02/24/graduatestudentretestqa/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络问题"><a href="#计算机网络问题" class="headerlink" title="计算机网络问题"></a>计算机网络问题</h2><ol><li><p>TCP/IP模型如何分层？路由器、网卡分别属于哪一层？</p><p> <img src="https://cdn.jsdelivr.net/gh/bigzcoder/PicBed/img/20210224155335.png" alt=""></p></li><li><p>解释网络中的频分多路复用(FDM)</p><p> 原理：整个传输频带被划分为若干个频率通道，每路信号占用一个频率通道进行传输。频率通道之间留有防护频带以防相互干扰。</p><p> 本质上把每路信息以某种调制方式（ASK、FSK、PSK）调制到不同频率的载波上，然后合并成一个信号送到信道上传输。接受方把接受到的信号通过滤波器，分离出各载波信号，再经过解调，借助低通滤波器将原始信号恢复出来</p></li><li><p>IPv4和IPv6有什么异同？</p><ul><li>位数不一样 一个2的32次方-1，一个2的128次方-1</li><li>网络地址表示法不一样 IPV6是冒号16进制</li><li>网络地址的分类方式不同 </li><li>改进的IP多播</li><li>IPV6比IPV4报头简单的多</li></ul></li><li><p>解释网关概念</p><ul><li>网关（Gateway）就是一个网络连接到另一个网络的“关口”。也就是网络关卡。</li><li>网关(Gateway)又称网间连接器、协议转换器。默认网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关的结构也和路由器类似，不同的是互连层。网关既可以用于广域网互连，也可以用于局域网互连。</li><li>历史的原因，许多有关TCP/IP的文献曾经把网络层使用的路由器称为网关（三层交换机也算网关设备）</li><li>应用层网关（也叫应用层防火墙或应用层代理防火墙）</li></ul></li><li><p>何为MIDI？何时使用MIDI更合适？</p><p> MIDI(Musical Instrument Digital Interface)乐器数字接口 ，是20 世纪80 年代初为解决电声乐器之间的通信问题而提出的。，可以把MIDI理解成是一种协议、一种标准、或是一种技术，但不要把它看作是某个硬件设备。MIDI 传输的不是声音信号， 而是音符、控制参数等指令, 它指示MIDI 设备要做什么，怎么做， 如演奏哪个音符、多大音量等。它们被统一表示成MIDI 消息(MIDI Message) 。传输时采用异步串行通信, 标准通信波特率为31.25×( 1±0.01) KBaud。</p></li><li><p>谈谈地址转换协议ARP的概念及特点。</p><ol><li>用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址。</li><li>在网络通信中，主机和主机通信的数据包需要依据OSI模型从上到下进行数据封装，当数据封装完整后，再向外发出。所以在局域网的通信中，不仅需要源目IP地址的封装，也需要源目MAC的封装。</li><li>一般情况下，上层应用程序更多关心IP地址而不关心MAC地址，所以需要通过ARP协议来获知目的主机的MAC地址，完成数据封装。</li></ol></li><li><p>谈谈对网络中广播和多播的认识。</p><ol><li>单播         - 一对一进行信息传输</li><li>多播（组播）  - 一对多进行信息传输，例如网络视频点播</li><li>广播         - 一对全局域网进行通信，如DHCP</li></ol></li><li><p>子网掩码的作用</p><p> 子网掩码(subnet mask)又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。</p></li><li><p>简述环形局域网的拓扑结构及工作原理。</p><p> 环形拓扑结构是一个像环一样的闭合链路，它是由许多中继器和通过中继器连接到链路上的节点连接而成。在环形网中，所有的通信共享一条物理通道，即连接了网中所有节点的点到点链路。</p><p> 环形拓扑结构由沿固定方向连接成封闭回路的网络节点组成，每一节点与它左右相邻的节点连接，是一个点对点的封闭结构。所有的节点公用一个信息环路，都可以提出发送数据的请求，获得发送权的节点可以发送数据。环形网络常使用令牌来决定哪个节点可以访问通信系统。在环形网络中信息流只能是单方向的，每个收到信息包的站点都向它的下游站点转发该信息包，直至目的节点。信息包在环网中“环游”一圈，最后由发送站进行回收，只有得到令牌的站才可以发送信息。每台设备都可直接连到环上，或通过一个接口设备和分支电缆连到环上。</p></li><li><p>提高网络链路的带宽，实际上是提高了什么？</p><p>增加了带宽，是在单位时间里提高了网络链路上传输的信息量。</p></li><li><p>什么是防火墙？防火墙的设计主要有哪些类型？</p><p>所谓防火墙指的是一个由软件和硬件设备组合而成、在内部网和外部网之间、专用网与公共网之间的界面上构造的保护屏障.是一种获取安全性方法的形象说法，它是一种计算机硬件和软件的结合，使Internet与Intranet之间建立起一个安全网关（Security Gateway），从而保护内部网免受非法用户的侵入，防火墙主要由服务访问规则、验证工具、包过滤和应用网关4个部分组成，防火墙就是一个位于计算机和它所连接的网络之间的软件或硬件。该计算机流入流出的所有网络通信和数据包均要经过此防火墙。</p><p>过滤型防火墙<br>过滤型防火墙是在网络层与传输层中，可以基于数据源头的地址以及协议类型等标志特征进行分析，确定是否可以通过。在符合防火墙规定标准之下，满足安全性能以及类型才可以进行信息的传递，而一些不安全的因素则会被防火墙过滤、阻挡。</p><p>应用代理类型防火墙<br>应用代理防火墙主要的工作范围就是在OSI的最高层，位于应用层之上。其主要的特征是可以完全隔离网络通信流，通过特定的代理程序就可以实现对应用层的监督与控制。这两种防火墙是应用较为普遍的防火墙，其他一些防火墙应用效果也较为显著，在实际应用中要综合具体的需求以及状况合理的选择防火墙的类型，这样才可以有效地避免防火墙的外部侵扰等问题的出现。</p><p>复合型<br>截至2018年应用较为广泛的防火墙技术当属复合型防火墙技术，综合了包过滤防火墙技术以及应用代理防火墙技术的优点，譬如发过来的安全策略是包过滤策略，那么可以针对报文的报头部分进行访问控制；如果安全策略是代理策略，就可以针对报文的内容数据进行访问控制，因此复合型防火墙技术综合了其组成部分的优点，同时摒弃了两种防火墙的原有缺点，大大提高了防火墙技术在应用实践中的灵活性和安全性。</p></li><li><p>请谈谈socket编程的基本过程</p><p><img src="https://cdn.jsdelivr.net/gh/bigzcoder/PicBed/img/20210301085246.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/bigzcoder/PicBed/img/20210301085342.png" alt=""></p><p>socket()-创建Socket；bind()-将创建的Socket与本地端口绑定；connect()与accept()-建立Socket连接；listen()-服务器监听是否有连接请求；send()-数据的可控缓冲发送；recv()-可控缓冲接收；closesocket()-关闭Socket</p></li><li><p>论述网络上常用的协议及其应用范围</p><p><img src="https://cdn.jsdelivr.net/gh/bigzcoder/PicBed/img/20210301095257.png" alt=""></p></li><li><p>简要介绍ADSL技术</p><p><img src="https://cdn.jsdelivr.net/gh/bigzcoder/PicBed/img/20210301101349.png" alt=""></p><p>ADSL(Asymmetric Digital Subscriber Line)，非对称数字用户线路，在电话线上产生三个信息通道：一个速率为1.5Mbps-9Mbps的高速下行通道，用于用户下载信息；一个速率为16Kbps-1Mbps的中速双工通道；一个普通的老式电话服务通道；且这三个通道可以同时工作。</p></li><li><p>什么是套接字？根据你的知识，谈谈对它的理解。</p><p>所谓套接字(Socket)，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议根进行交互的接口。</p></li><li><p>谈谈Intranet与Internet的区别和联系。</p><p>Intranet称为企业内部网，或称内部网、内联网、内网，是一个使用与因特网同样技术的计算机网络，它通常建立在一个企业或组织的内部并为其成员提供信息的共享和交流等服务，例如万维网，文件传输，电子邮件等。</p><p>Internet是公众网,任何人都可以从任意节点登录上去并访问整个网络的信息;而Intranet则是内部网,不仅被防火墙与Internet分隔开来,而且内部通常还有严密的安全体系,未授权的用户无法访问其中的信息。</p><p>Internet的信息主要是公众性的,大部分都是广告、新闻、免费软件等等;而Intranet中的信息是公司内部的,不用于对外公布,主要是公司人事信息、技术信息和财务信息等等。 </p><p>Internet十分庞大,管理非常复杂,各个节点的通信线路也各式各样,运行效率难以保障;而Intranet相对来说规模小得多,管理比较严格,网络线路一般都比较好,因此运行性能较高。</p></li><li><p>谈一谈网络层和运输层之间的关系</p><p>类比A家庭和B家庭，A1小孩和B1小孩的通信<br>实际就是运输层完成了对网络层的复用</p></li><li><p>OSI七层模型是什么？</p><p><img src="https://cdn.jsdelivr.net/gh/bigzcoder/PicBed/img/20210301104902.png" alt=""></p></li><li><p>简述局域网与分布式系统异同点。</p><p>我们将地理位置不同，具有独立功能的多个计算机系统，通过通信设备和线路互相连接起来，使用功能完整的网络软件来实现网络资源共享的大系统，称为计算机网络。换句话说，计算机网络既可以用通信线路将几台计算机系统连成简单的网络，实现信息的收集、分配、传输和处理，也可以将成千上万的计算机系统和数千公里乃至数万公里的通信线路联成全国或全球的计算机网络。按照网络覆盖的地区不同，可把计算机网分成局域网（LAN）、广域网（WAN）、都市网（MAN）以及网间网（INTERNET）等。</p><p>分布式系统（distributed system）是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。</p><p>分布式数据库系统由分布于多个计算机结点上的若干个数据库系统组成,它提供有效的存取手段来操纵这些结点上的子数据库。分布式数据库在使用上可视为一个完整的数据库,而实际上它是分布在地理分散的各个结点上。当然,分布在各个结点上的子数据库在逻辑上是相关的。</p></li><li><p>论述OSI协议七层参考模型和TCP/IP五层参考模型。并且说出它们的主要区别。</p><p><img src="https://cdn.jsdelivr.net/gh/bigzcoder/PicBed/img/20210302091746.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/bigzcoder/PicBed/img/20210302091838.gif" alt=""></p><ul><li>层数不一样</li><li>最终tcpip成为事实上的标准，osi很美好，但是没有商业驱动力</li></ul></li><li><p>MAC地址、IP地址、端口三者的区别和联系</p><p>mac地址是在数据链路层包裹在以太网头部中的，它主要用来识别同一个链路中的不同计算机。Mac地址即网卡号，每块网卡出厂的时候，都有一个全世界独一无二的 MAC 地址，长度是 48 个二进制位，通常用 12 个十六进制数表示。</p><p>IP地址是在网络层的IP头部里，用于识别网络中互联的主机和路由器，其实主要是确认子网，通过子网掩码确认某个IP地址所在的子网，而后再在子网内部确认mac地址就能找到准确的用户了。</p><p>端口号是在运输层包含在TCP/UDP头部中的，用于识别应用程序。一台主机上能运行多个程序，那么接收到的消息到底是哪个程序发送的，就需要端口号来确认。</p></li><li><p>什么是数据传输速率？两种传输速率的含义及其关系是什么？</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>混合内容如何修复</title>
      <link href="/2021/02/14/webtipssolvemixedcontent/"/>
      <url>/2021/02/14/webtipssolvemixedcontent/</url>
      
        <content type="html"><![CDATA[<p>当用户访问使用HTTPS的页面时，他们与web服务器之间的连接是使用SSL加密的，从而保护连接不受嗅探器和中间人攻击。</p><p>如果HTTPS页面包括由普通明文HTTP连接加密的内容，那么连接只是被部分加密：非加密的内容可以被嗅探者入侵，并且可以被中间人攻击者修改，因此连接不再受到保护。当一个网页出现这种情况时，它被称为混合内容页面。</p><pre class=" language-txt"><code class="language-txt">How to fix your websiteSectionThe best strategy to avoid mixed content blocking is to serve all the content as HTTPS instead of HTTP.For your own domain, serve all content as HTTPS and fix your links.  Often, the HTTPS version of the content already exists and this just requires adding an "s" to links - http:// to https://.However, in some cases, the path may just be incorrect to the media in question. There are online as well as offline tools (depending on your operating system) such as linkchecker to help resolve this.For other domains, use the site's HTTPS version if available. If HTTPS is not available, you can try contacting the domain and asking them if they can make the content available via HTTPS.</code></pre><p>如何修复？<br>最好的解决办法就是让所有混合内容使用https打开，就解决了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发者需知 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3浅谈弹性盒子Flex</title>
      <link href="/2021/02/14/webtipsflexlayout/"/>
      <url>/2021/02/14/webtipsflexlayout/</url>
      
        <content type="html"><![CDATA[<h2 id="flex弹性盒模型"><a href="#flex弹性盒模型" class="headerlink" title="flex弹性盒模型"></a>flex弹性盒模型</h2><p><img src="flexExplain.jpeg" alt="flex流程图"></p><p>测试代码贴出</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">            <span class="token selector">body</span><span class="token punctuation">{</span>                <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/* 设置flex布局 */</span>                <span class="token property">flex-direction</span><span class="token punctuation">:</span> row<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/* 设置主轴 */</span>                <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>vh<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/* 相对视口高度 */</span>                <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/* 设置主轴的对其方式 =>水平居中 */</span>                <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/* 设置交叉轴的对其方式 =>垂直居中 */</span>            <span class="token punctuation">}</span>            <span class="token selector"><span class="token id">#t</span></span><span class="token punctuation">{</span>                <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#000000</span><span class="token punctuation">;</span>                <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>                <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>t<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>浏览运行结果<br><img src="flexResult.png" alt="flexResult"></p><blockquote><p>引用<br><a href="https://www.cnblogs.com/qcloud1001/p/9848619.html" target="_blank" rel="noopener">30分钟彻底弄懂flex布局</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过CSS选择器制作超链接动态下划线</title>
      <link href="/2021/02/14/webtipscss3ab/"/>
      <url>/2021/02/14/webtipscss3ab/</url>
      
        <content type="html"><![CDATA[<h2 id="结果图"><a href="#结果图" class="headerlink" title="结果图"></a>结果图</h2><p><img src="css3ab.gif" alt="flex流程图"></p><p>超链接代码</p><pre class=" language-css"><code class="language-css"><span class="token selector">a </span><span class="token punctuation">{</span>    <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">15</span>px<span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#fff</span><span class="token punctuation">;</span>    <span class="token property">text-decoration</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>    <span class="token property">line-height</span><span class="token punctuation">:</span> <span class="token number">36</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>因为设置下划线的位置是绝对位置，肯定要相对于<code>a</code>标签来显示下划线，所以<code>a</code>标签要设置<code>position:relative</code></p><hr><p><code>:before</code>的意思是在每个元素之前插入内容，原理其实就是在<code>a</code>标签下边插入一根线，替换成代码就是<code>a</code>标签前边定位到底部的一个元素</p><p>对于<code>a:before</code>需要设置下 <code>position: absolute</code></p><pre class=" language-css"><code class="language-css"><span class="token selector">a<span class="token pseudo-element">:before</span> </span><span class="token punctuation">{</span>    <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">2</span>px<span class="token punctuation">;</span>    <span class="token property">bottom</span><span class="token punctuation">:</span> -<span class="token number">5</span>px<span class="token punctuation">;</span>    <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#000</span><span class="token punctuation">;</span>    <span class="token property">visibility</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>    <span class="token property">-webkit-transform</span><span class="token punctuation">:</span> <span class="token function">scaleX</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">-o-transform</span><span class="token punctuation">:</span> <span class="token function">scaleX</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scaleX</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">-webkit-transition</span><span class="token punctuation">:</span> all <span class="token number">0.3</span>s ease-in-out <span class="token number">0</span>s<span class="token punctuation">;</span>    <span class="token property">-o-transition</span><span class="token punctuation">:</span> all <span class="token number">0.3</span>s ease-in-out <span class="token number">0</span>s<span class="token punctuation">;</span>    <span class="token property">transition</span><span class="token punctuation">:</span> all <span class="token number">0.3</span>s ease-in-out <span class="token number">0</span>s<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>下边这个是设置，当鼠标移动上去，下划线从0过度为1，铺满整个宽度。</p><pre class=" language-css"><code class="language-css"><span class="token selector">a<span class="token pseudo-class">:hover</span><span class="token pseudo-element">:before</span> </span><span class="token punctuation">{</span>    <span class="token property">visibility</span><span class="token punctuation">:</span> visible<span class="token punctuation">;</span>    <span class="token property">-webkit-transform</span><span class="token punctuation">:</span> <span class="token function">scaleX</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">-o-transform</span><span class="token punctuation">:</span> <span class="token function">scaleX</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scaleX</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>引用<br><a href="http://www.runoob.com/cssref/css-selectors.html" target="_blank" rel="noopener">http://www.runoob.com/cssref/css-selectors.html</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软工结构化分析&amp;结构化设计的思维导图</title>
      <link href="/2021/02/14/softwareengswdt/"/>
      <url>/2021/02/14/softwareengswdt/</url>
      
        <content type="html"><![CDATA[<p>软件工程做一个小小总结</p><ul><li>第五章结构化设计<br><img src="01.jpg" alt=""></li><li>第四章结构化分析<br><img src="02.jpg" alt=""></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RIP和OSPF路由协议简单学习</title>
      <link href="/2021/02/14/rip-ospf/"/>
      <url>/2021/02/14/rip-ospf/</url>
      
        <content type="html"><![CDATA[<h2 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>RIP（Routing Information Protocol）是一种分布式的基于距离向的路由选择协议，适合小型互联网。</p><blockquote><p>关于距离<br>每经历一个路由器，跳数就加1</p></blockquote><ol><li>仅和相邻路由器交换信息。</li><li>交换的信息是当前本路由器知道的全部信息，即自己现在的路由表。</li><li>按固定的时间间隔交换信息。</li></ol><h3 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h3><p>设X结点是A到B的最短路径的一个结点，若把路径A-&gt;B拆成两段路径A-&gt;X和X-&gt;B，则每一段路径也都是最短路径。</p><p><img src="01.png" alt="RIP计算Demo"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点<ul><li>实现简单，开销小</li></ul></li><li>缺点<ul><li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。 </li><li>“坏消息传播得慢”，使更新过程的收敛时间过长。</li></ul></li></ul><h2 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h2><h3 id="OSPF协议的基本特点"><a href="#OSPF协议的基本特点" class="headerlink" title="OSPF协议的基本特点"></a>OSPF协议的基本特点</h3><p>开放最短路径优先 OSPF (Open Shortest Path First)</p><ul><li><code>开放</code>表明 OSPF 协议不是受某一家厂商控制，而是公开发表的。</li><li><code>最短路径优先</code> 是因为使用了 Dijkstra 提出的最短路径算法 SPF</li><li>采用分布式的链路状态协议 (link state protocol)。 </li></ul><blockquote><p>注意：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。</p></blockquote><h3 id="OSPF的三个要点"><a href="#OSPF的三个要点" class="headerlink" title="OSPF的三个要点"></a>OSPF的三个要点</h3><ul><li>向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。</li><li>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。<blockquote><p>“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。 </p></blockquote></li><li>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。  </li></ul><h3 id="链路数据库"><a href="#链路数据库" class="headerlink" title="链路数据库"></a>链路数据库</h3><ul><li>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。</li><li>这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（这称为链路状态数据库的同步）。</li><li>OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。</li><li>OSPF 的更新过程收敛得快是其重要优点。</li></ul><h3 id="OSPF的区域"><a href="#OSPF的区域" class="headerlink" title="OSPF的区域"></a>OSPF的区域</h3><p>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫做区域。<br>每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。<br>区域也不能太大，在一个区域内的路由器最好不超过 200 个。  </p><h3 id="原理形象解释"><a href="#原理形象解释" class="headerlink" title="原理形象解释"></a>原理形象解释</h3><pre class=" language-txt"><code class="language-txt">OSPF协议，类似车载导航系统，将每条道路都收集到自己的数据库里。当计算上海到北京的最短路径时，有以下选择：  （1）沈海高速—长深高速—荣乌高速—京沪高速  （2）京沪高速—滨莱高速—荣乌高速  （3）京沪高速—泰新高速—京台高速—廊沧高速第一条路径最短，优先选择。如果遇到中途“荣乌高速”严重堵车，可以提前切换到京沪高速，提高通行的效率。  OSPF比RIP强大的地方是，OSPF对整网的拓扑结构了如指掌，一旦某一条路径断了，可以及时选择备份链路，对通信的影响小。  RIP是基于谣言，对整网的拓扑结构没有概念，只知道有几个邻居，至于更远的邻居是什么样子，对不起，不知道！作者：车小胖链接：https://www.zhihu.com/question/62872429/answer/419024597来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x32dbg实战——深入追超级录像专家</title>
      <link href="/2021/01/26/x32dbgdeepfindcode/"/>
      <url>/2021/01/26/x32dbgdeepfindcode/</url>
      
        <content type="html"><![CDATA[<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>x32dbg</li><li>IP Search</li><li>PEid</li></ul><a id="more"></a><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol><li>查壳</li></ol><p><img src="01.png" alt="01.png"></p><ol start="2"><li>拉进x32dbg，找注册失败后的字符串</li></ol><p><img src="02.png" alt="02.png"></p><p>错误提示</p><p><img src="03.png" alt="03.png"></p><p>找到错误提示的字符串位置，并且跳转</p><ol start="3"><li>找到关键call，并且开始断点调试</li></ol><p><img src="04.png" alt="04.png"></p><ol start="4"><li>断点调试后，发现关键call上边都没出现注册码，于是要单步进入关键call，看其内部调用</li></ol><p><img src="05.png" alt="05.png"></p><p>发现关键字符串 </p><pre><code>dword ptr [ebp-4]=[0018FB8C &amp;"Pict-1313ureRe-138C"]=01E47670 "Pict-1313ureRe-138C"</code></pre><ol start="5"><li>用注册码 “Pict-1313ureRe-138C” 测试下</li></ol><p><img src="06.png" alt="06.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有时候通过单步跳过执行过程是看不到注册码的，需要进入call里边才能看到，并且此程序和IPSearch一样属于注册表注册，无法通过破坏验证来完成注册<br>在这个程序里边还发现了一点，程序是通过某种算法来算出注册码的，具有不一致性，可能一个机器生效的注册码换一个就失效了，这种需要生成注册机，破解算法。</p><p><img src="07.png" alt="07.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>鸣谢：吾爱技术吧</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x32dbg实战——追IPSearch注册码</title>
      <link href="/2021/01/26/crushsoftwarebase2/"/>
      <url>/2021/01/26/crushsoftwarebase2/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><ul><li>x32dbg</li><li>IP Search</li><li>PEid</li></ul><a id="more"></a><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol><li>查壳</li></ol><p><img src="01.png" alt="01.png"></p><p>发现没壳，可以直接调试</p><ol start="2"><li>导入x32dbg分析</li></ol><p><img src="02.png" alt="02.png"></p><p>输入一个错误的注册码，点击注册，然后蹦出来错误提示框</p><p><img src="03.png" alt="03.png"></p><p>搜索该字符串</p><p><img src="04.png" alt="04.png"></p><p>双击跳转，并分析跳转后的结果</p><p><img src="05.png" alt="05.png"></p><p>在关键跳上边打上断点，开始测试程序</p><p><img src="06.png" alt="06.png"></p><p>找到注册码，并且尝试注册</p><p><img src="07.png" alt="07.png"></p><p>根据上图完成了注册</p><p>对于这个程序，如果跳过比较注册码的过程，直接跳转到正确结果的话，就算是注册成功，从新启动之后还是需要从新注册（因为程序是检测注册表来判断是否注册成功）</p><p><img src="08.png" alt="08.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>调试的过程中，除了破坏验证时候跳转的判断，还有去追注册码<br>有些程序破坏验证是不可用的，需要具体问题具体分析。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x32dbg破解简单软件</title>
      <link href="/2021/01/23/crushsoftwarebase/"/>
      <url>/2021/01/23/crushsoftwarebase/</url>
      
        <content type="html"><![CDATA[<h1 id="x32dbg破解简单软件"><a href="#x32dbg破解简单软件" class="headerlink" title="x32dbg破解简单软件"></a>x32dbg破解简单软件</h1><blockquote><p>鸣谢：吾爱技术吧</p></blockquote><h2 id="前提需要知道的知识"><a href="#前提需要知道的知识" class="headerlink" title="前提需要知道的知识"></a>前提需要知道的知识</h2><h3 id="软件版本分类"><a href="#软件版本分类" class="headerlink" title="软件版本分类"></a>软件版本分类</h3><pre class=" language-html"><code class="language-html">一般分为以下几类： 【商业版】：也就是正规的商业发行版，这种软件本应通过正规购买方式获得，但网络上一些朋友将这些软件进行技术处理之后以软件包的形式提供下载，一般来说在使用上和正规购买的版本没有什么区别。 【试用版】：这类软件一般是商业软件开发商自己通过网络提供于大家下载的。但和正式商业版相比在功能上会有一定限制，比如原来在网络上提供的金山2003试用版。就有使用次数的限制。 【共享版】：也就是共享软件，这类软件一般是由个人开发完成，只通过网络下载的方式发行，但软件开发者为了获取利益，会对软件进行技术处理，在未向作者正式购买该软件之前会在使用过程中受到一定限制，如只能使用30天，或者某些高级功能无法使用。当使用者向作者付款之后，会通过比如注册码方式对软进行解锁，从而能够无障碍使用该软件。 【免费版】：和共享软件一样，大多由个人开发，但却是免费提供给大家使用，没有任何功能或时间、次数上的限制。但一般不允许对该软件进行二次开发或用于商业赢利目的。 【自由版】：也就是自由软件，这类软件不但向使用者提供没有任何限制的使用权限，而且遵循相关的自由软件授权协议允许任何人对该软件进行二次开发或用于商业用途，甚至有时会提供软件源代码（LINUX软件大多属于此类）。 【破解板】（注册版）：严格来说这不属于一种授权版本，因为他是针对商业版、试用版、共享版这类有使用限制的软件进行二次开发之后形成的特殊版本，也就是说，使用者可以在没有任何经济付出的条件下无限制的使用该软件的</code></pre><h3 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h3><ol><li>查壳<blockquote><p>PEID–功能强大的侦壳工具，自带脱壳插件（但是，效果不怎么样）<br>工作原理：核心是userdb.txt（大家看看就完全明白了）[通过壳的入口特征码进行辨认]</p></blockquote></li><li>od<blockquote><p>强大的反汇编工具，也是现在最常用的</p></blockquote></li><li>Dump<blockquote><p>OD自带的脱壳插件–到达OEP之后右键。。。<br>LordPE、PeDumper–选择所调试的进程–右键–完整脱壳</p></blockquote></li><li>修复<blockquote><p>Import REConstructor 1.6</p></blockquote></li><li>VMware<blockquote><p>虚拟机</p></blockquote></li></ol><h3 id="认识软件是否加密"><a href="#认识软件是否加密" class="headerlink" title="认识软件是否加密"></a>认识软件是否加密</h3><p>通过特征来判断</p><pre class=" language-html"><code class="language-html">----------------------------------------------------------------------------Microsoft Visual C++ 6.000496EB8 >/$  55            PUSH EBP                                 ;  (初始 cpu 选择)00496EB9  |.  8BEC          MOV EBP,ESP00496EBB  |.  6A FF         PUSH -100496EBD  |.  68 40375600   PUSH Screensh.0056374000496EC2  |.  68 8CC74900   PUSH Screensh.0049C78C                   ;  SE 处理程序安装00496EC7  |.  64:A1 0000000>MOV EAX,DWORD PTR FS:[0]00496ECD  |.  50            PUSH EAX00496ECE  |.  64:8925 00000>MOV DWORD PTR FS:[0],ESP00496ED5  |.  83EC 58       SUB ESP,58----------------------------------------------------------------------------Microsoft Visual Basic 5.0 / 6.000401166  - FF25 6C104000   JMP DWORD PTR DS:[<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>&amp;MSVBVM60.#100</span><span class="token punctuation">></span></span>]      ; MSVBVM60.ThunRTMain0040116C >  68 147C4000     PUSH PACKME.00407C1400401171    E8 F0FFFFFF     CALL <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>JMP.&amp;MSVBVM60.#100</span><span class="token punctuation">></span></span>00401176    0000            ADD BYTE PTR DS:[EAX],AL00401178    0000            ADD BYTE PTR DS:[EAX],AL0040117A    0000            ADD BYTE PTR DS:[EAX],AL0040117C    3000            XOR BYTE PTR DS:[EAX],AL----------------------------------------------------------------------------BC++0040163C > $ /EB 10         JMP SHORT BCLOCK.0040164E0040163E     |66            DB 66                                    ;  CHAR 'f'0040163F     |62            DB 62                                    ;  CHAR 'b'00401640     |3A            DB 3A                                    ;  CHAR ':'00401641     |43            DB 43                                    ;  CHAR 'C'00401642     |2B            DB 2B                                    ;  CHAR '+'00401643     |2B            DB 2B                                    ;  CHAR '+'00401644     |48            DB 48                                    ;  CHAR 'H'00401645     |4F            DB 4F                                    ;  CHAR 'O'00401646     |4F            DB 4F                                    ;  CHAR 'O'00401647     |4B            DB 4B                                    ;  CHAR 'K'00401648     |90            NOP00401649     |E9            DB E90040164A   . |98E04E00      DD OFFSET BCLOCK.___CPPdebugHook0040164E   > \A1 8BE04E00   MOV EAX,DWORD PTR DS:[4EE08B]00401653   .  C1E0 02       SHL EAX,200401656   .  A3 8FE04E00   MOV DWORD PTR DS:[4EE08F],EAX0040165B   .  52            PUSH EDX0040165C   .  6A 00         PUSH 0                                   ; /pModule = NULL0040165E   .  E8 DFBC0E00   CALL <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>JMP.&amp;KERNEL32.GetModuleHandleA</span><span class="token punctuation">></span></span>    ; \GetModuleHandleA00401663   .  8BD0          MOV EDX,EAX----------------------------------------------------------------------------Borland Delphi 6.0 - 7.000509CB0 > $  55            PUSH EBP00509CB1   .  8BEC          MOV EBP,ESP00509CB3   .  83C4 EC       ADD ESP,-1400509CB6   .  53            PUSH EBX00509CB7   .  56            PUSH ESI00509CB8   .  57            PUSH EDI00509CB9   .  33C0          XOR EAX,EAX00509CBB   .  8945 EC       MOV DWORD PTR SS:[EBP-14],EAX00509CBE   .  B8 20975000   MOV EAX,unpack.0050972000509CC3   .  E8 84CCEFFF   CALL unpack.0040694C----------------------------------------------------------------------------易语言入口00401000 >  E8 06000000     call dump_.0040100B00401005    50              push eax00401006    E8 BB010000     call <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jmp.&amp;KERNEL32.ExitProcess</span><span class="token punctuation">></span></span>0040100B    55              push ebp0040100C    8BEC            mov ebp,esp0040100E    81C4 F0FEFFFF   add esp,-11000401014    E9 83000000     jmp dump_.0040109C00401019    6B72 6E 6C      imul esi,dword ptr ds:[edx+6E],6C0040101D    6E              outs dx,byte ptr es:[edi]也可能是这样的入口Microsoft Visual C++ 6.0 [Overlay] E语言00403831 >/$  55            PUSH EBP00403832  |.  8BEC          MOV EBP,ESP00403834  |.  6A FF         PUSH -100403836  |.  68 F0624000   PUSH Nisy521.004062F00040383B  |.  68 A44C4000   PUSH Nisy521.00404CA4                    ;  SE 处理程序安装00403840  |.  64:A1 0000000>MOV EAX,DWORD PTR FS:[0]00403846  |.  50            PUSH EAX00403847  |.  64:8925 00000>MOV DWORD PTR FS:[0],ESP----------------------------------------------------------------------------MASM32 / TASM32入口00401258 >/$  6A 00         push 0                                   ; /pModule = NULL0040125A  |.  E8 47000000   call <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jmp.&amp;kernel32.GetModuleHandleA</span><span class="token punctuation">></span></span>    ; \GetModuleHandleA0040125F  |.  A3 00304000   mov dword ptr ds:[403000],eax00401264  |.  6A 00         push 0                                   ; /lParam = NULL00401266  |.  68 DF104000   push dump.004010DF                       ; |DlgProc = dump.004010DF0040126B  |.  6A 00         push 0                                   ; |hOwner = NULL0040126D  |.  6A 65         push 65                                  ; |pTemplate = 650040126F  |.  FF35 00304000 push dword ptr ds:[403000]               ; |hInst = NULL00401275  |.  E8 56000000   call &lt;jmp.&amp;user32.DialogBoxPar----------------------------------------------------------------------------MASM32 / TASM32入口00401258 >/$  6A 00         push 0                                   ; /pModule = NULL0040125A  |.  E8 47000000   call <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jmp.&amp;kernel32.GetModuleHandleA</span><span class="token punctuation">></span></span>    ; \GetModuleHandleA0040125F  |.  A3 00304000   mov dword ptr ds:[403000],eax00401264  |.  6A 00         push 0                                   ; /lParam = NULL00401266  |.  68 DF104000   push dump.004010DF                       ; |DlgProc = dump.004010DF0040126B  |.  6A 00         push 0                                   ; |hOwner = NULL0040126D  |.  6A 65         push 65                                  ; |pTemplate = 650040126F  |.  FF35 00304000 push dword ptr ds:[403000]               ; |hInst = NULL00401275  |.  E8 56000000   call &lt;jmp.&amp;user32.DialogBoxPar</code></pre><h3 id="汇编简单基础"><a href="#汇编简单基础" class="headerlink" title="汇编简单基础"></a>汇编简单基础</h3><pre class=" language-html"><code class="language-html">cmp    a,b     //  比较a与bmov    a,b     //  把b值送给a值，使a=bret            //  返回主程序nop            //  无作用call           //  调用子程序，子程序以ret结尾je或jz         //  相等则跳（机器码是74或84）jne或jnz       //  不相等则跳（机器码是75或85）jmp            //  无条件跳（机器码是EB）jb             //  若小于则跳ja             //  若大于则跳jg             //  若大于则跳jge            //  若大于等于则跳jl             //  若小于则跳pop xxx        //  xxx出栈push xxx       //  xxx压栈// ...</code></pre><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>破解第一个简单程序</p><p><img src="01.png" alt="01.png"></p><p>注册码输入正确就显示以下跳转</p><p><img src="02.png" alt="02.png"></p><p>错误则报错</p><p><img src="05.png" alt="05.png"></p><ol><li>拖拽<code>.exe</code>到PEid查壳</li></ol><p><img src="03.png" alt="03.png"></p><p>发现此程序没有壳，是易语言通过vc++最后编译出来的程序，带着vc++的特征码</p><ol start="2"><li>拖拽<code>.exe</code>到x32dbg，并搜索字符串</li></ol><p><img src="04.png" alt="04.png"></p><ol start="3"><li>在字符串界面找到提示的字符，双击跳转查看执行过程。或者直接找到注册码，完成破解</li></ol><p><img src="06.png" alt="06.png"></p><ol start="4"><li>分析程序，找到关键call（注册成功和失败的调用），关键call上边的地方有关键跳</li></ol><p><img src="07.png" alt="07.png"></p><ol start="5"><li>将此处的逻辑用<code>NOP</code>填充或者<code>je</code>改为<code>jne</code>（破坏跳转逻辑，使跳转不成立）,进而输入错误的注册码也可以执行</li></ol><p><img src="08.png" alt="08.png"></p><ol start="6"><li>通过debug的方式看程序是否在这个地方直接执行注册，不进行跳转（此处不再演示）</li><li>通过打补丁的方式，将补丁打给此程序的一个副本，实现破解</li></ol><p><img src="09.png" alt="09.png"></p><ol start="8"><li>测试破解是否成功</li></ol><p><img src="10.png" alt="10.png"></p><p>通过错误的注册码进入了正确的成功界面，破坏了判断错误后的跳转，直接进入正确的跳转，破解成功。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>破解步骤</p><ul><li>查壳破壳</li><li>拉入程序到x32dbg</li><li>通过程序特征（字符串、事件等）去找关键call，进而找到关键跳，破坏验证的关键跳 | 或者找到注册码</li><li>如果破坏了关键跳，记得给程序打上补丁，完成破解</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的STL容器</title>
      <link href="/2021/01/16/c-stlinstruction/"/>
      <url>/2021/01/16/c-stlinstruction/</url>
      
        <content type="html"><![CDATA[<h1 id="算法设计工具STL"><a href="#算法设计工具STL" class="headerlink" title="算法设计工具STL"></a>算法设计工具STL</h1><h2 id="STL概述"><a href="#STL概述" class="headerlink" title="STL概述"></a>STL概述</h2><h3 id="STL组成成分"><a href="#STL组成成分" class="headerlink" title="STL组成成分"></a>STL组成成分</h3><p>STL主要由</p><ul><li>container - 容器</li><li>algorithm - 算法</li><li>iterator - 迭代器</li></ul><p>三大件组成</p><a id="more"></a><h3 id="什么是STL容器"><a href="#什么是STL容器" class="headerlink" title="什么是STL容器"></a>什么是STL容器</h3><p>简单说STL容器就是一种数据结构</p><pre class=" language-txt"><code class="language-txt">注意：C++引入了命名空间概念，在不同命名空间中可以存在相同名字的标识符。</code></pre><pre class=" language-c"><code class="language-c">using namespace std<span class="token punctuation">;</span></code></pre><ul><li>常用的数据结构和相应头文件</li></ul><table><thead><tr><th>数据结构</th><th>说明</th><th>头文件</th></tr></thead><tbody><tr><td>vector</td><td>底层是数组，支持随机访问</td><td>&lt;vector&gt;</td></tr><tr><td>string</td><td>字符处理容器</td><td>&lt;string&gt;</td></tr><tr><td>deque</td><td>双端队列</td><td>&lt;deque&gt;</td></tr><tr><td>list</td><td>链表，底层为双向链表</td><td>&lt;list&gt;</td></tr><tr><td>stack</td><td>栈</td><td>&lt;stack&gt;</td></tr><tr><td>queue</td><td>队列</td><td>&lt;queue&gt;</td></tr><tr><td>priority-queue</td><td>优先队列</td><td>&lt;queue&gt;</td></tr><tr><td>set/multiset</td><td>结点组成的红黑树</td><td>&lt;set&gt;</td></tr><tr><td>map/mutimap</td><td>key-value结构，底层红黑树</td><td>&lt;map&gt;</td></tr></tbody></table><h3 id="什么是STL算法"><a href="#什么是STL算法" class="headerlink" title="什么是STL算法"></a>什么是STL算法</h3><p>STL算法是用来操作容器中数据的模板函数，大概100个算法模板函数</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">testSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>a<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printArray</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="什么是STL迭代器"><a href="#什么是STL迭代器" class="headerlink" title="什么是STL迭代器"></a>什么是STL迭代器</h3><p>简单地说，STL迭代器用于访问容器中数据对象。</p><p>常用迭代器</p><ul><li>iterator - 指向容器中存放元素的迭代器，用于正向遍历容器中的元素</li><li>const_iterator - 指向容器中存放元素的常量迭代器，只能读取容器11中的元素</li><li>reverse_iterator - 指向容器中存放元素的反响迭代器，用于反向遍历容器中的元素</li><li>const_reverse_iterator - 常量反向迭代器</li></ul><p>迭代器常用操作：</p><ul><li>++ 正向移动迭代器</li><li>– 反向移动迭代器</li><li>* 返回迭代器值</li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">testFrontIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> myv<span class="token punctuation">;</span>    myv<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    myv<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    myv<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>iterator it<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>it<span class="token operator">=</span>myv<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>myv<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>it<span class="token punctuation">)</span><span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">testBackIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> myv<span class="token punctuation">;</span>    myv<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    myv<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    myv<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>reverse_iterator rit<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>rit<span class="token operator">=</span>myv<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>rit<span class="token operator">!=</span>myv<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>rit<span class="token punctuation">)</span><span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>rit<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="常用的STL容器"><a href="#常用的STL容器" class="headerlink" title="常用的STL容器"></a>常用的STL容器</h2><h3 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h3><h4 id="vector-向量容器"><a href="#vector-向量容器" class="headerlink" title="vector 向量容器"></a>vector 向量容器</h4><p>它是一个向量类模版。向量容器相当于数组，操作起来和数组的优缺点一样</p><p>定义方式</p><pre class=" language-c"><code class="language-c">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v1<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 定义元素为int的向量v1</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">v2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 指向向量v2的初始大小为10个int元素</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> <span class="token function">v3</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">1.23</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指向v3的10个初始元素的初值为1.23</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">v4</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>a<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 用数组a 0～4共5个元素初始化v4</span></code></pre><p>vector提供了一系列的成员函数</p><pre class=" language-txt"><code class="language-txt">- empty()               判断当前向量是否为空- size()                返回当前容量中实际元素个数- []                    返回指定下标元素- reserve(n)            为当前向量容器预分配n个元素的存储空间- capacity()            返回当前向量容器在重新进行内存分配以前所能容纳的个数- resize(n)             调整当前容量容器大小，使其能容纳n个元素- push_back()           在当前向量容器尾部添加一个元素- insert(pos,elem)      在pos位置插入元素elem，即将元素elem插入迭代器pos指向位置之前- front()               获取当前向量容器的第一个元素- back()                获取当前向量容器的最后一个元素- erase()               删除当前向量向量容器中某个迭代器或者迭代器区间指定的元素- clear()               删除当前想向量容器中的所有元素- begin()               该函数的两个版本返回iterator或const_iterator，引用容器第一个元素- end()                 该函数的两个版本返回... ,引用容器的最后一个位置- rbegin()              该函数的两个版本返回reverse_iterator或const_reverse_iterator，引用容器的最后一个元素- rend()                与rbegin反过来</code></pre><p>关于size和capacity区别</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>using std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"v.size() == "</span> <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" v.capacity() = "</span> <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>    v<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"v.size() == "</span> <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" v.capacity() = "</span> <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>    v<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"v.size() == "</span> <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" v.capacity() = "</span> <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>执行结果</p><p><img src="1.png" alt="01.jpg"></p><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>string是一个保存字符序列的容器，类似于vector&lt;char&gt;</p><p>定义方式</p><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span> cstr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"China!Greate Wall"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 字符串</span>string <span class="token function">s1</span><span class="token punctuation">(</span>cstr<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// s1 "China! Greate Wall"</span>string <span class="token function">s2</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">// s2 "China! Greate Wall"</span>string <span class="token function">s3</span><span class="token punctuation">(</span>cstr<span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// s3 "Greate Wall"</span>string <span class="token function">s4</span><span class="token punctuation">(</span>cstr<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">// s4 "China"</span>string <span class="token function">s5</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">// s5 "AAAAA"</span></code></pre><p>操作方式</p><pre class=" language-txt"><code class="language-txt">empty()                                                  判断当前字符串是否为空串size()                                                   返回当前字符串实际字符个数（返回结果为size_type类型）length()                                                 返回当前字符串实际字符个数[idx]                                                    返回当前字符串位于idx位置的字符，idx从0开始at(idx)                                                  返回当前字符串位于idx位置的字符compare(const string& str)                               返回当前字符串与字符串str的比较结果。相等是0，前者小于后者返回-1，否则返回1append(cstr)                                             在当前字符串的末尾添加一个字符串strinsert(size_type idx,const string& str)                  在当前字符串的idx处插入一个字符串strfind(string& s,size_type pos)                            从当前字符串中的pos位置开始查找字符串s的第一个位置，找到返回其位置，若没有找到返回-1replace(size_type idx,size_type len,const string& str)   将当前字符串中起始于idx的len个字符用一个字符串str替换substr(size_type idx)                                    返回当前字符串起始于idx的子串             substr(size_type idx,size_type len)                      返回当前字符串起始于idx的长度为len的子串clear()                                                  删除当前字符串中的所有字符erase()                                                  删除当前字符串中的所有字符erase(size_type idx)                                     删除当前字符串换从idx开始的所有字符erase(size_type idx,size_type len)                       删除当前字符串从idx开始的len个字符</code></pre><p>实例</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">testString2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    string s1<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">,</span>s2<span class="token punctuation">,</span>s3<span class="token operator">=</span><span class="token string">"Bye"</span><span class="token punctuation">;</span>    s1<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"Good morning"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    s2<span class="token operator">=</span>s1<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span>s2<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"morning"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    s2<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>s2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token punctuation">,</span>s3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 相当于s2.replace(5,7,s3);</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"s1:"</span><span class="token operator">&lt;&lt;</span>s1<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"s2:"</span><span class="token operator">&lt;&lt;</span>s2<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="deque-双端队列容器"><a href="#deque-双端队列容器" class="headerlink" title="deque 双端队列容器"></a>deque 双端队列容器</h4><p>双端队列容器由若干个块构成，每个块中元素的地址是连续的，块之间的地址是不连续的</p><p>定义方式</p><pre class=" language-c"><code class="language-c">deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> dq1<span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">// 指定元素为int的双端队列dq1</span>deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dq2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 指定dq2的初始大小为10个int元素</span>deque<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> <span class="token function">dq3</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">1.23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 指定dq3的10个初始元素为1.23</span>deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dq4</span><span class="token punctuation">(</span>dq2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dq2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 用dq2的所有元素初始化dq4</span></code></pre><p>主要函数</p><pre class=" language-txt"><code class="language-txt">empty()size()front()back()push_front(elem)push_back(elem)pop_front()pop_back()erase()clear()begin()end()rbegin()rend()</code></pre><p>实例</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">disp</span><span class="token punctuation">(</span>deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>dq<span class="token punctuation">)</span><span class="token punctuation">{</span>    deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>iterator iter<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>iter<span class="token operator">=</span>dq<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>iter<span class="token operator">!=</span>dq<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>iter<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>iter<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">testDeque</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> dq<span class="token punctuation">;</span>    dq<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dq<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dq<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dq<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"dq:"</span><span class="token punctuation">;</span>    <span class="token function">disp</span><span class="token punctuation">(</span>dq<span class="token punctuation">)</span><span class="token punctuation">;</span>    dq<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dq<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">disp</span><span class="token punctuation">(</span>dq<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="list-链表"><a href="#list-链表" class="headerlink" title="list 链表"></a>list 链表</h4><p>实际是一个双向链表</p><p>定义方式</p><pre class=" language-c"><code class="language-c">list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> l1<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 定义元素为int的链表l1</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">l2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 指定链表l2的初始大小为10个int 元素</span>list<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> <span class="token function">l3</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">1.23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 指定l3的10个初始大小的初值1.23</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">l4</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>a<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 用数组a[0..4]共5个元素初始化14</span></code></pre><p>主要操作</p><pre class=" language-c"><code class="language-c"><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">remove_if</span><span class="token punctuation">(</span>cmp<span class="token punctuation">)</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">insert</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span>elem<span class="token punctuation">)</span><span class="token function">insert</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span>n<span class="token punctuation">,</span>elem<span class="token punctuation">)</span><span class="token function">insert</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span>pos1<span class="token punctuation">,</span>pos2<span class="token punctuation">)</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>示例</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">disp_list</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>lst<span class="token punctuation">)</span><span class="token punctuation">{</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator it<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>it<span class="token operator">=</span>lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>lst<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">testList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst<span class="token punctuation">;</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator it<span class="token punctuation">,</span>start<span class="token punctuation">,</span>end<span class="token punctuation">,</span>temp<span class="token punctuation">;</span>    lst<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lst<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lst<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lst<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lst<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"初始lst"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token function">disp_list</span><span class="token punctuation">(</span>lst<span class="token punctuation">)</span><span class="token punctuation">;</span>    it<span class="token operator">=</span>lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    start<span class="token operator">=</span><span class="token operator">++</span>lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    end<span class="token operator">=</span><span class="token operator">--</span>lst<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    temp<span class="token operator">=</span>lst<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// lst.end(); 在最后位置+1</span>    lst<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span>start<span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// start在2的位置，end在3的位置，it在5的位置</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"执行后lst.insert(it,start,end);"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token function">disp_list</span><span class="token punctuation">(</span>lst<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 显示将 2 4 1 插入到5前边</span><span class="token punctuation">}</span></code></pre><h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><p>关联容器中的每个元素都有一个key（关键字），通过key来存储和读取元素，这些关键字可能与元素所在容器的位置无关，所以关联容器不提供顺序容器中的front()、push_front()、back()、push_back()、以及pop_back()等操作</p><h4 id="set-multiset-集合容器-多重集合容器"><a href="#set-multiset-集合容器-多重集合容器" class="headerlink" title="set/multiset 集合容器/多重集合容器"></a>set/multiset 集合容器/多重集合容器</h4><h4 id="map-multimap-映射容器-多重映射容器"><a href="#map-multimap-映射容器-多重映射容器" class="headerlink" title="map/multimap 映射容器/多重映射容器"></a>map/multimap 映射容器/多重映射容器</h4><h3 id="适配器容器"><a href="#适配器容器" class="headerlink" title="适配器容器"></a>适配器容器</h3><h4 id="stack-栈容器"><a href="#stack-栈容器" class="headerlink" title="stack 栈容器"></a>stack 栈容器</h4><p>默认底层是deque，用户也可以指定其他底层容器</p><p>定义</p><pre class=" language-c"><code class="language-c">stack<span class="token operator">&lt;</span>string<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> myst<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 第二个参数指定底层容器为vector</span></code></pre><p>操作</p><blockquote><p>栈只有一个出口，所以没有迭代器操作</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">push</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>例子</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">testStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>    st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"栈顶元素:"</span><span class="token operator">&lt;&lt;</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"出栈顺序"</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>        st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="queue-队列容器"><a href="#queue-队列容器" class="headerlink" title="queue 队列容器"></a>queue 队列容器</h4><p>定义与stack相似</p><blockquote><p>queue容器不允许顺序遍历，没有迭代器操作</p></blockquote><p>操作</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">push</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>例子</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">testQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> qu<span class="token punctuation">;</span>    qu<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    qu<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    qu<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"队头元素:"</span><span class="token operator">&lt;&lt;</span>qu<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"队尾元素:"</span><span class="token operator">&lt;&lt;</span>qu<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"出队元素"</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>qu<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span>qu<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>        qu<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="priority-queue-优先队列"><a href="#priority-queue-优先队列" class="headerlink" title="priority_queue 优先队列"></a>priority_queue 优先队列</h4><p>内置函数，需要重新定义优先运算符</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>STL<ul><li>STL概述 - 三大件 容器 算法 迭代器<ul><li>什么是STL容器</li><li>什么是STL算法</li><li>什么是STL迭代器</li></ul></li><li>常用STL容器<ul><li>顺序容器<ul><li>vector !</li><li>string !</li><li>deque</li><li>list !</li></ul></li><li>关联容器<ul><li>set</li><li>map </li></ul></li><li>适配器容器<ul><li>stack !</li><li>queue !</li><li>priority_queue</li></ul></li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年7月16日日记-2010英语卷</title>
      <link href="/2020/07/16/2020716/"/>
      <url>/2020/07/16/2020716/</url>
      
        <content type="html"><![CDATA[<p>今天开始锻炼了！希望未来能够每天坚持，让自己拥有一个好的身体。  </p><p>线代的学习也加快步伐了  </p><a id="more"></a><h2 id="英语摘抄"><a href="#英语摘抄" class="headerlink" title="英语摘抄"></a>英语摘抄</h2><p>But the epidemic is “moderate” in severity, according to Margaret Chan, the organization’s directior general, with the overwhelming majority of patients experiencing only symptoms and a full recovery, often in the absense of any medical treatment.</p><blockquote><p>但根据世界卫生组织总干事陈冯富珍称，此次传染病的严重程度“中等”，绝大多数患者只有轻微症状，通常不用借助任何治疗能够完全康复。</p></blockquote><p>The heightened alert followed an emergency meeting with flu experts in Geneva that assembled after a sharp rise in cases in Australia，and rising numbers in Britain, Japan, Chile and elsewhere.</p><blockquote><p>随着澳大利亚病例的急剧增多，以及英国、日本、智利和其他地区感染人数的不断上升，流感专家们在日内瓦召开了紧急会议，随后警惕升级了。</p></blockquote><p>More than three million doses were to be made available in early October 2009, though most of those inital doses were of the FluMist nasal spray type,which is not recommended for pregnant women, people over 50 or those with breathing difficulties, heart disease or several other problems.</p><blockquote><p>2009年10月初，有三百多万剂投入使用，尽管这批初期药剂中的大部分为FluMist鼻用喷雾剂型疫苗，是不建议孕妇、50岁以上或有呼吸困难、心脏疾病或一些其他疾病的人群使用的。</p></blockquote><p>But the market generates interest far beyond its size because it brings together great wealth, enormous egos, greed, passion and controversy in a way matched by few other industries.</p><blockquote><p>但这一市场产生的利益远远超出它本身的规模，因为它将大量财富、膨胀的自我、贪婪、激情和争议以一种其他行业无法比拟的方式汇集在了一起。</p></blockquote><p>This episode crystallizes the irony that although American men tend to talk more than women in public situations, they often talk less at home.</p><blockquote><p>这段情节证明了一种具有讽刺意味的现象的确存在；尽管美国男性倾向于在公共场合比女性健谈，在家里却比妻子话少。</p></blockquote><p>In short，the image that best represents the current crisis is the stereotypical cartoon scene of a man sitting at the breakfast table with a newspaper held up in front of his face, while a woman glares at the back of it,wanting to talk.</p><blockquote><p>简言之，最能形象表现目前这种危机的是这样的经典漫画场景：一个男人坐在早餐桌边，手中报纸挡住他的脸，一个女人怒视报纸背面，很想交谈。</p></blockquote><p>The companies that Dr.Curtis turned to —— P&amp;G, C-P and U —— had invested hundreds of millions of dollars finding the subtle cues in consumers’lives that corporations could use to introduce new routines.</p><blockquote><p>柯提斯博士求助的公司有宝洁、高露洁和联合利华，这些公司曾经投资几亿美元用于发觉消费者生活中的微妙暗示，并利用它们引入新惯例。</p></blockquote><p>Today, beacause of shrewd advertising and public health campaigns, many Americans habitually give their pearly whites a cavity-preventing scrub twice a day, often with Colgate, Crest or one of the other brands.</p><blockquote><p>而今天，受精明的广告活动和公共卫生运动的影响，许多美国人会习惯性地每天给他们那如珍珠般洁白的牙齿做两次龋齿预防刷洗，他们使用的，往往就是高露洁、佳洁士或者其他某种品牌。</p></blockquote><p>Although the Supreme Court of the United States had prohibited intentional racial discrimination in jury selection as early as the 1880 case of SWV, the practice of selecting so-called elite or blue-ribbon juries provided a convenient way around this and other antidiscrimination laws.</p><blockquote><p>尽管美国最高法院早在1880年的SWV一案中就已经禁止了陪审团遴选中的蓄意种族歧视，但挑选所谓的精英陪审员或者蓝带陪审员的做法，却为绕开这一反歧视及其他反歧视提供了一条捷径。</p></blockquote><p>In the landmark 1975 decision T, the Supreme Court extended the requirement that juries be representative of all parts of the community to the state level.</p><blockquote><p>在1975年泰勒诉路易安那州一案里程碑式的裁定中，最高法院将陪审团成员需代表社会各阶层这一要求延伸至州级层面。</p></blockquote><p>Many Americans regard the jury system as a concrete expression of crucial democratic values, including the principles that all citizens who meet minimal qualifications of age and literacy are equally competent to serve on juries; that jurors should be selected randomly from a  representative cross section of the community; that no citizen should be denied the right to serve on a jury on account of race, religion, sex, or national origin; that defendants are entitled to trial by their peers; and that verdicts should represent the conscience of community and not just the letter of the law.</p><blockquote><p>许多美国人把陪审团制度看作是关键民主价值观的具体表现，该制度包括以下原则；所有满足最低年龄和文化要求的公民都具备同等资格担任陪审员；陪审员应从社会各部门的典型代表中随机挑选；任何公民不得由种族、宗教、性别和民族出身被剥夺担任陪审员的权利；被告人有权利接收由同等地位人的审判；审判结果应该代表社会良知，而不仅仅是法律条文的字面意义。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo自动化工具</title>
      <link href="/2020/06/27/autohexomaker/"/>
      <url>/2020/06/27/autohexomaker/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo自动化工具"><a href="#hexo自动化工具" class="headerlink" title="hexo自动化工具"></a>hexo自动化工具</h2><p>为解决hexo每次写文章都需要输一堆命令，写文章的时候需要手动创建以及添加配置，以及gitee更新还需要登录账号这好多步骤的操作，于是想要把所有的操作集中到一个GUI的工具执行</p><a id="more"></a><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li>首先需要安装node.js，Git，并且将node.js Git都已经配置到环境变量（安装包的时候默认添加）</li><li>然后配置VisialCode到环境变量，因为要执行创建文章的时候顺带也打开了，打开的工具使用的是VisualCode</li><li>在hexo博客所在目录位置<code>_config.yml</code>文件中的<code>deploy</code>项，设置好<code>repo</code>。</li><li>在gitee设置好自己的私人令牌，拿到token填写到程序中。</li></ol><h3 id="软件操作"><a href="#软件操作" class="headerlink" title="软件操作"></a>软件操作</h3><ul><li><p>首先选择博客所安放的目录<br><img src="01.png" alt="02"></p></li><li><p>接着开始调试、写文章、改博客代码等操作。</p></li></ul><p>调试<br><img src="https://cdn.jsdelivr.net/gh/bigzcoder/PicBed/img/02.gif" alt=""></p><p>写文章<br><img src="https://cdn.jsdelivr.net/gh/bigzcoder/PicBed/img/03.gif" alt=""></p><ul><li>做完所有修改博客的行为之后就是<code>打包--&gt;部署--&gt;更新</code> 一条龙服务！最后访问自己的域名便可。</li></ul><blockquote><p>※打包就是把所有博客文件生成一堆静态文件，意义是gitee或者github不用再下载npm的一堆依赖了。<br>※部署就是把打包后的静态文件，部署到gitee pages或者github pages<br>※更新专门针对的是gitee，gitee需要手动更新gitee pages，这里需要用户自己的令牌token来完成更新api的操作。</p></blockquote><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><p>唯一让我调试了多次主要还是访问远程api</p><pre class=" language-java"><code class="language-java">HTTP http <span class="token operator">=</span> HTTP<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HttpCall post <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">async</span><span class="token punctuation">(</span><span class="token string">"https://gitee.com/api/v5/repos/bigzcoder/bigzcoder/pages/builds"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setOnResponse</span><span class="token punctuation">(</span><span class="token punctuation">(</span>HttpResult result<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addHeader</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"application/json"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">addBodyParam</span><span class="token punctuation">(</span><span class="token string">"access_token"</span><span class="token punctuation">,</span> <span class="token string">"****d9229103dd92ad95**"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>新建文章主要是用了IO操作，把文章的文件以及文件夹写到<code>sources/_post</code>里边</p><pre class=" language-java"><code class="language-java">fileDir<span class="token punctuation">.</span><span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Date date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>SimpleDateFormat formatter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>file<span class="token punctuation">.</span><span class="token function">createNewFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建文件输出流</span>bw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedWriter</span><span class="token punctuation">(</span>fw<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用缓冲区数据流封装输出流</span><span class="token function">write</span><span class="token punctuation">(</span>bw<span class="token punctuation">,</span> <span class="token string">"---"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span>bw<span class="token punctuation">,</span> <span class="token string">"title: "</span> <span class="token operator">+</span> PostConfigSetView<span class="token punctuation">.</span>postTitle<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span>bw<span class="token punctuation">,</span> <span class="token string">"date: "</span> <span class="token operator">+</span> formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span>bw<span class="token punctuation">,</span> <span class="token string">"tags: "</span> <span class="token operator">+</span> PostConfigSetView<span class="token punctuation">.</span>postTags<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span>bw<span class="token punctuation">,</span> <span class="token string">"description: "</span> <span class="token operator">+</span> PostConfigSetView<span class="token punctuation">.</span>postDescrption<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span>bw<span class="token punctuation">,</span> <span class="token string">"categories: "</span> <span class="token operator">+</span> PostConfigSetView<span class="token punctuation">.</span>postCategories<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span>bw<span class="token punctuation">,</span> <span class="token string">"feature: "</span> <span class="token operator">+</span> PostConfigSetView<span class="token punctuation">.</span>postFeature<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span>bw<span class="token punctuation">,</span> <span class="token string">"toc: "</span> <span class="token operator">+</span> PostConfigSetView<span class="token punctuation">.</span>postToc<span class="token punctuation">.</span><span class="token function">isSelected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span>bw<span class="token punctuation">,</span> <span class="token string">"---"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>JOptionPane<span class="token punctuation">.</span><span class="token function">showMessageDialog</span><span class="token punctuation">(</span>MainFrame<span class="token punctuation">.</span>mainWorkSpace<span class="token punctuation">,</span> <span class="token string">"文件写入成功！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MainFrame<span class="token punctuation">.</span>displayArea<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"文件写入成功！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MainFrame<span class="token punctuation">.</span>displayArea<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"文章路径："</span> <span class="token operator">+</span> file <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MainFrame<span class="token punctuation">.</span>displayArea<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"文件夹路径："</span> <span class="token operator">+</span> fileDir <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>部署更新都是直接用的api调用npx hexo的命令，非常简单，不多说了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>自己写完图形的话，最大的好处就是集成操作，一个程序，做了所有事情。不然重复的事情其实挺折磨人的。<br>源码已经上传到github上，用了自取哈。</p><p>项目地址：<code>git clone https://github.com/bigzcoder/hexo-.git</code>，欢迎clone ^_^。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HelloWorld</title>
      <link href="/2020/06/26/helloworld/"/>
      <url>/2020/06/26/helloworld/</url>
      
        <content type="html"><![CDATA[<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>还在上学，坐标河南，方向有两个。</p><ul><li>考研</li><li>写点代码，提提升自己</li><li>写点文章，抒发感情，并且提高写作水平。</li></ul><a id="more"></a><h2 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h2><p>未来主要写两方面的东西</p><ul><li>记录生活</li><li>记录学习</li></ul><blockquote><p>可能未来还记录一些工作</p></blockquote><h2 id="关于梦想"><a href="#关于梦想" class="headerlink" title="关于梦想"></a>关于梦想</h2><p>目前盼望有俩，一是考研，二是好工作。<br>未来的话，希望能实现人生价值，为社会做点贡献，来提高自己的成就感吧。</p><h2 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h2><p>QQ：<code>840350739</code>，记得备注来自博客哦^_^</p><h2 id="感谢博客主题"><a href="#感谢博客主题" class="headerlink" title="感谢博客主题"></a>感谢博客主题</h2><p>主题传送门 –&gt; <code>https://github.com/blinkfox/hexo-theme-matery</code></p><p><img src="https://cdn.jsdelivr.net/gh/bigzcoder/PicBed/img/20210224110714.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 个人日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图常用的两种存储结构</title>
      <link href="/2019/05/11/datastructbasegraph/"/>
      <url>/2019/05/11/datastructbasegraph/</url>
      
        <content type="html"><![CDATA[<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>邻接矩阵（Adjacency Matrix）是表示顶点之间相邻关系的<font color="red">矩阵/数组。</font></p><h3 id="图的邻接矩阵存储结构"><a href="#图的邻接矩阵存储结构" class="headerlink" title="图的邻接矩阵存储结构"></a>图的邻接矩阵存储结构</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">int</span> VerTexType<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 假设顶点的数据类型为字符型 </span><span class="token keyword">typedef</span> <span class="token keyword">int</span> ArcType<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 假设边的权值类型为整形</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    VerTexType vexs<span class="token punctuation">[</span>MVNum<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 顶点表</span>    ArcType arcs<span class="token punctuation">[</span>MVNum<span class="token punctuation">]</span><span class="token punctuation">[</span>MVNum<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 邻接矩阵</span>    <span class="token keyword">int</span> vexnum<span class="token punctuation">,</span>arcnum<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 图的当前点数和边数 </span><span class="token punctuation">}</span>AMGraph<span class="token punctuation">;</span> </code></pre><p>对于G表示结点之间的连接关系，<code>A[i][j]</code>的位置如果存储是1表示<code>i</code>和<code>j</code>点是连接的，0则不连接<br>对于G是网络来说，<code>A[i][j]</code>存放的是两点之间的权值，有权值必代表连接，反正则用<code>∞</code>来表示没有连接，自然也没有了权值    </p><h3 id="使用邻接矩阵表示法创建无向网-图"><a href="#使用邻接矩阵表示法创建无向网-图" class="headerlink" title="使用邻接矩阵表示法创建无向网/图"></a>使用邻接矩阵表示法创建无向网/图</h3><ul><li>无项网   </li></ul><pre class=" language-cpp"><code class="language-cpp">Status <span class="token function">CreateUDN</span><span class="token punctuation">(</span>AMGraph <span class="token operator">&amp;</span>G<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 采用邻接矩阵表示法，创建无项网G</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">,</span>w<span class="token punctuation">;</span>    VerTexType v1<span class="token punctuation">,</span>v2<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入总顶点数，总边数:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">,</span><span class="token operator">&amp;</span>G<span class="token punctuation">.</span>arcnum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入顶点数据："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>G<span class="token punctuation">.</span>vexs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"初始化网络 ...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            G<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>MaxInt<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"初始化成功 ...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">&lt;=</span>G<span class="token punctuation">.</span>arcnum<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入一条边依附的两个顶点和权值:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>v1<span class="token punctuation">,</span><span class="token operator">&amp;</span>v2<span class="token punctuation">,</span><span class="token operator">&amp;</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        i<span class="token operator">=</span><span class="token function">LocateVex</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>        j<span class="token operator">=</span><span class="token function">LocateVex</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 确认v1和v2在G中的位置，即顶点数组的下标</span>        G<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>w<span class="token punctuation">;</span>        G<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>G<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 依附顶点</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>无向图   </li></ul><pre class=" language-cpp"><code class="language-cpp">Status <span class="token function">CreateUDG</span><span class="token punctuation">(</span>AMGraph <span class="token operator">&amp;</span>G<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 采用邻接矩阵表示法，创建无项图G</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">;</span>    VerTexType v1<span class="token punctuation">,</span>v2<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入总顶点数，总边数:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">,</span><span class="token operator">&amp;</span>G<span class="token punctuation">.</span>arcnum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入顶点数据："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>G<span class="token punctuation">.</span>vexs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"初始化图 ...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            G<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"初始化成功 ...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">&lt;=</span>G<span class="token punctuation">.</span>arcnum<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入一条边依附的两个顶点:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>v1<span class="token punctuation">,</span><span class="token operator">&amp;</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>        i<span class="token operator">=</span><span class="token function">LocateVex</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>        j<span class="token operator">=</span><span class="token function">LocateVex</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 确认v1和v2在G中的位置，即顶点数组的下标</span>        G<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        G<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 依附顶点</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>两者的区别也就是在<code>a[i][j]</code>的位置存储的值不一样，一个多存储了权值，一个值存储了连接关系，实际代码也就在存储的时候有所改变</p><p>邻接矩阵的缺点是，如果图是足够稀疏的话，对空间是一种浪费，所以邻接矩阵适合稠密图，优点是便于计算各个顶点的度。更多的优缺点在这里不再赘述，课本中有足够的内容来充实这一部分</p><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>邻接表（Adjacency List）是图的一种链式存储结构。邻接表中，对图中每个顶点<code>v[i]</code>建立一个单链表，把与<code>v[i]</code>相邻的顶点放入这个表中。</p><h3 id="邻接表的存储结构"><a href="#邻接表的存储结构" class="headerlink" title="邻接表的存储结构"></a>邻接表的存储结构</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">int</span> OtherInfo<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> VerTexType<span class="token punctuation">;</span><span class="token keyword">struct</span> ArcNode<span class="token punctuation">{</span>    <span class="token keyword">int</span> adjvex<span class="token punctuation">;</span>    <span class="token keyword">struct</span> ArcNode <span class="token operator">*</span>nextarc<span class="token punctuation">;</span>    OtherInfo info<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">typedef</span> <span class="token keyword">struct</span> VNode<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 顶点信息 </span>    VerTexType data<span class="token punctuation">;</span>    ArcNode    <span class="token operator">*</span>firstarc<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 指向第一条依附该顶点的边的指针 </span><span class="token punctuation">}</span>VNode<span class="token punctuation">,</span>AdjList<span class="token punctuation">[</span>MVNum<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    AdjList vertices<span class="token punctuation">;</span>    <span class="token keyword">int</span> vexnum<span class="token punctuation">,</span>arcnum<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 图的当前顶点数和边数 </span><span class="token punctuation">}</span>ALGraph<span class="token punctuation">;</span></code></pre><h3 id="使用邻接表表示法创建无向图"><a href="#使用邻接表表示法创建无向图" class="headerlink" title="使用邻接表表示法创建无向图"></a>使用邻接表表示法创建无向图</h3><pre class=" language-cpp"><code class="language-cpp">Status <span class="token function">CreateUDG</span><span class="token punctuation">(</span>ALGraph <span class="token operator">&amp;</span>G<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 采用邻接表表示法，创建无向图</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">;</span>    VerTexType v1<span class="token punctuation">,</span>v2<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入总顶点数，总边数:"</span><span class="token punctuation">;</span>    cin<span class="token operator">>></span>G<span class="token punctuation">.</span>vexnum<span class="token operator">>></span>G<span class="token punctuation">.</span>arcnum<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 输入总顶点数，总边数 </span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入顶点数据:"</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cin<span class="token operator">>></span>G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 输入顶点值</span>        G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 初始化表头结点的指针域为NULL </span>    <span class="token punctuation">}</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入每个边依附的两个顶点"</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>arcnum<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 输入各边，构造邻接表</span>        cin <span class="token operator">>></span> v1 <span class="token operator">>></span> v2<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 输入一条边依附的两个顶点</span>        i<span class="token operator">=</span><span class="token function">LocateVex</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>        j<span class="token operator">=</span><span class="token function">LocateVex</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 确定v1和v2在G中位置，即顶点在G.vertices中的序号</span>        ArcNode<span class="token operator">*</span> p1<span class="token operator">=</span><span class="token punctuation">(</span>ArcNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ArcNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 生成另一个对称的新的边结点*p1</span>        p1<span class="token operator">-</span><span class="token operator">></span>adjvex<span class="token operator">=</span>j<span class="token punctuation">;</span>                                        <span class="token comment" spellcheck="true">// 邻接点序号为j    </span>        p1<span class="token operator">-</span><span class="token operator">></span>nextarc<span class="token operator">=</span>G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span>        G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token operator">=</span>p1<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 将新结点*p1插入顶点vi的边表头部 </span>        ArcNode<span class="token operator">*</span> p2<span class="token operator">=</span><span class="token punctuation">(</span>ArcNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ArcNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 生成另一个对称的新的边结点*p1</span>        p2<span class="token operator">-</span><span class="token operator">></span>adjvex<span class="token operator">=</span>i<span class="token punctuation">;</span>                                        <span class="token comment" spellcheck="true">// 邻接点序号为i    </span>        p2<span class="token operator">-</span><span class="token operator">></span>nextarc<span class="token operator">=</span>G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span>        G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token operator">=</span>p2<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 将新结点*p1插入顶点vi的边表头部 </span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如果想用邻接表创建网的话，在<code>ArcNode</code>的这个结构体里边的<code>info</code>放上权值就可以了。<br>邻接表的有点就是便于增加和删除顶点，便于统计边的数目。<br>缺点是不便于判断顶点之间是否有边。<br>邻接表适合稀疏图   </p><hr><p>补充一点，关于有向图和无向图的两种数据结构创建，无非就是少存储一条边，而且方向要明确，这里不再展示代码。</p><blockquote><p>数据结构C语言版 严蔚敏 李冬梅 吴伟民</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈弗曼树编码</title>
      <link href="/2019/05/08/datastructhuffmantreecode/"/>
      <url>/2019/05/08/datastructhuffmantreecode/</url>
      
        <content type="html"><![CDATA[<h2 id="哈夫曼编码的主要思想"><a href="#哈夫曼编码的主要思想" class="headerlink" title="哈夫曼编码的主要思想"></a>哈夫曼编码的主要思想</h2><p>为出现次数较多的字符编以较短的编码，为确保对数据文件进行有效的压缩和对压缩文件进行正确的编码，可以利用哈夫曼树来设计二进制编码  </p><p>下面是有关编码的两个概念</p><ol><li>前缀编码：如果在一个编码方案中，任一个编码都不是其他编码的前缀（最左字串），则称是前缀编码</li><li>哈夫曼编码：对一颗具有n个叶子的哈夫曼树，若对树中每个左分支赋予0，右分支赋予1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码。</li><li>哈夫曼编码满足下边两个性质。</li></ol><p><strong>性质一</strong> 哈夫曼编码是前缀编码<br><strong>性质二</strong> 哈夫曼编码是最优前缀编码</p><p>对于包含<code>n</code>个字符的数据文件，分别以它们的出现次数为权值构造哈夫曼树，则利用该树对应的哈夫曼树对文件进行编码，能使该文件压缩后对应的二进制文件的长度最短。</p><h2 id="哈夫曼树编码的实现"><a href="#哈夫曼树编码的实现" class="headerlink" title="哈夫曼树编码的实现"></a>哈夫曼树编码的实现</h2><h3 id="创建一棵哈夫曼树"><a href="#创建一棵哈夫曼树" class="headerlink" title="创建一棵哈夫曼树"></a>创建一棵哈夫曼树</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 数据 5 29 7 8 14 23 3 11 </span><span class="token function">CreateHuffmanTree</span><span class="token punctuation">(</span>HF<span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">TraverHiffmanTreeData</span><span class="token punctuation">(</span>HF<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 遍历</span></code></pre><h3 id="创建哈夫曼编码的字符串指针"><a href="#创建哈夫曼编码的字符串指针" class="headerlink" title="创建哈夫曼编码的字符串指针"></a>创建哈夫曼编码的字符串指针</h3><pre class=" language-c"><code class="language-c"><span class="token function">CreateHuffmanCode</span><span class="token punctuation">(</span>HF<span class="token punctuation">,</span>HC<span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">TraverseHuffmanCode</span><span class="token punctuation">(</span>HC<span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 遍历</span></code></pre><p>哈夫曼树的创建和遍历，之前的文章已经介绍过了</p><p>这里只分析<code>CreateHuffmanCode</code>这段代码，遍历二叉树编码相当于遍历一组字符串数组，非常简单。</p><h3 id="CreateHuffmanCode函数代码"><a href="#CreateHuffmanCode函数代码" class="headerlink" title="CreateHuffmanCode函数代码"></a>CreateHuffmanCode函数代码</h3><p>哈夫曼树表的存储表示</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>HuffmanCode<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 动态分配数组存储哈夫曼编码表 </span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">CreateHuffmanCode</span><span class="token punctuation">(</span>HuffmanTree HF<span class="token punctuation">,</span>HuffmanCode <span class="token operator">&amp;</span>HC<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表HC中</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>start<span class="token punctuation">,</span>c<span class="token punctuation">,</span>f<span class="token punctuation">;</span>    HC<span class="token operator">=</span><span class="token punctuation">(</span>HuffmanCode<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 分配存储n个字符编码的编码表空间 </span>    <span class="token keyword">char</span><span class="token operator">*</span> cd<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 分配临时存放每个字符编码的动态数组空间</span>    cd<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'\0'</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                    <span class="token comment" spellcheck="true">// 逐个字符求哈夫曼编码 </span>        start<span class="token operator">=</span>n<span class="token number">-1</span><span class="token punctuation">;</span>                                        <span class="token comment" spellcheck="true">// start开始时指向最后，即编码结束</span>        c<span class="token operator">=</span>i<span class="token punctuation">;</span>        f<span class="token operator">=</span>HF<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>f<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            start<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>HF<span class="token punctuation">[</span>f<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild<span class="token operator">==</span>c<span class="token punctuation">)</span>                cd<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'0'</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                 cd<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'1'</span><span class="token punctuation">;</span>            c<span class="token operator">=</span>f<span class="token punctuation">;</span>            f<span class="token operator">=</span>HF<span class="token punctuation">[</span>f<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        HC<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>new <span class="token keyword">char</span><span class="token punctuation">[</span>n<span class="token operator">-</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">strcpy</span><span class="token punctuation">(</span>HC<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>cd<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">free</span><span class="token punctuation">(</span>cd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> </code></pre><p>函数的主要思想是从哈夫曼树的叶子出发，向上回溯到根结点。<br>步骤：<br>1 分配存储<code>n</code>个字符编码的编码表空间<code>HC</code>，长度<code>n+1</code>；分配临时存储每个字符的字符编码的动态数组<code>cd</code>，<code>cd[n-1]</code>置为<code>'\0'</code><br>2 逐个求解<code>n</code>个字符的编码，循环<code>n</code>次，  </p><ul><li>设置变量<code>start</code>用于纪录编码<code>cd</code>中的存放位置，<code>start</code>初始时指向最后，即编码结束的位置是<code>n-1</code>；</li><li>设置变量<code>c</code>用于纪录从叶子结点向上回溯至根结点所经过的结点下标，<code>c</code>初始时为当前待编码字符的下标<code>i</code>，<code>f</code>用于纪录<code>i</code>的双亲结点的下标；<ul><li>从叶子结点向上回溯至根结点，求得字符<code>i</code>的编码，当<code>f</code>没有到达根结点时，循环执行以下操作：</li><li>回溯一次<code>start</code>向前一个位置，即<code>start--</code></li><li>若结点<code>c</code>是<code>f</code>的左孩子，则生成代码0，否则生成代码1，生成的代码0和1保存在<code>cd[start]</code>中；<ul><li>继续向上回溯，改变c和f的值。</li></ul></li></ul></li><li>根据数组<code>cd</code>的字符长度为第<code>i</code>个字符编码分配空间<code>HC[i]</code>，然后将数组<code>cd</code>中的编码复制到<code>HC[i]</code>中。</li></ul><p>3 释放临时空间<code>cd</code> </p><p><font color="red">A：n指的什么？</font><br><font color="blue">Q：n指的所有的叶子结点</font><br><font color="red">A：HC申请的空间为什么既可以是n又可以是n+1？</font><br><font color="blue">Q：#</font>  </p><blockquote><p>数据结构[C语言版] 严蔚敏 李冬梅 吴伟民</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈夫曼树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序 Collection</title>
      <link href="/2019/05/08/datastructsortkey/"/>
      <url>/2019/05/08/datastructsortkey/</url>
      
        <content type="html"><![CDATA[<h1 id="基础排序的一些方法"><a href="#基础排序的一些方法" class="headerlink" title="基础排序的一些方法"></a>基础排序的一些方法</h1><p>数据结构按照顺序表</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> key<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//关键字项，关键字类型为整形</span>    <span class="token keyword">char</span> <span class="token operator">*</span>otherinfo<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//其它数据项</span><span class="token punctuation">}</span>RedType<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//记录类型</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    RedType r<span class="token punctuation">[</span>MAXSIZE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//0号单元闲置</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//顺序表长度</span><span class="token punctuation">}</span>SqList<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//顺序表类型</span></code></pre><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>基本思想：每一趟将一个待排序的记录，按其关键字的大小插入到前面已经排好的子序列中的适当位置，直到全部待排序的记录插入完成为止</p><p>排序过程：</p><ul><li>设待排序设待排序的记录<code>n</code>个存放在顺序表中<code>L</code>中（<code>L.r[1]...L.r[n]</code>)</li><li>先将序列中第1个记录看成是一个有序子序列<code>(L.r[i])</code></li><li>然后从第2个记录开始，逐个进行插入，直至整个序列有序。</li><li>整个排序过程需要<code>n-1</code>趟</li></ul><p>过程如下</p><p><img src="DataStructInsertSort.png" alt="DataStructInsertSort"></p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 进行L.length-1趟排序</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">// 将L.r[i]插入有序子表</span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token keyword">int</span> j<span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">// 将待插入的记录暂存到监视哨中</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token number">-1</span><span class="token punctuation">;</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 从后向前寻找插入位置</span>                L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 记录向后移动</span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">// 插入到正确位置</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h2><p>基本思想：利用折半查找的方法在当前的有序区域查找位置，由此得到的插入排序算法为“折半插入排序”</p><p>若有序区中不存在和待插入记录相同的关键字，则折半查找过程的结束条件为<code>low&gt;high</code>,此时插入位置为<code>?</code></p><p><code>low(high+1)</code></p><p>若有序区中存在和待插入记录相同的关键字，当<code>mid</code>指示的记录关键字等于待插入记录的关键字时，此时，继续在后半区间进行查找，直到<code>low&gt;high</code>，此时插入位置为<code>low"(high+1)</code>指示的位置</p><p>过程如下<br><img src="DataStructBinarySort.png" alt="DataStructBinarySort"></p><p>//对顺序表L中的记录进行折半插入排序</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">BInsertSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 将L.r[i]暂存到L.r[0]</span>        <span class="token keyword">int</span> low<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token operator">=</span>i<span class="token number">-1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span><span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">// 在r[low..high]中折半查找插入位置 </span>            <span class="token keyword">int</span> m<span class="token operator">=</span><span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>                high<span class="token operator">=</span>m<span class="token number">-1</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 插入点在低半区 </span>            <span class="token keyword">else</span>                low<span class="token operator">=</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 插入点在高半区 </span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token number">-1</span><span class="token punctuation">;</span>j<span class="token operator">>=</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">--</span>j<span class="token punctuation">)</span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 记录后移 </span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 插入 </span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>在直接插入排序中，当待排序纪录个数较少且待排序列的关键字基本有序时，排序效率较高。</p><p>希尔排序从“减少记录个数”和“序列基本有序”两个方面对直接插入排序进行改进。</p><p>基本思想：先取一个正整数<code>dl&lt;n</code>作为一个增量，把所有相隔dl的记录放一组，组内进行直接插入排序；然后取<code>d2&lt;d1</code>作为第二个增量，重复上述分组和排序操作；直至<code>di=1</code>，即所有记录放进一个组中排序为止</p><p>排序过程<br><img src="DataStructShellSort.png" alt="DataStructShellSort"></p><p><img src="DataStructShellsortAnim2.gif" alt="DataStructShellsortAnim2"></p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//对顺序表L中的记录进行一趟增量为dk的希尔排序</span><span class="token keyword">void</span> <span class="token function">ShellInsert</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> dk<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//请补充该操作</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>dk<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token operator">-</span>dk<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 将L.r[i]插入有序子表 </span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 用L.r[0]暂存待插入记录L.r[i] </span>            <span class="token keyword">int</span> j<span class="token punctuation">;</span>             <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">-</span>dk<span class="token punctuation">;</span>j<span class="token operator">></span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span>j<span class="token operator">-</span><span class="token operator">=</span>dk<span class="token punctuation">)</span>                L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span>dk<span class="token punctuation">]</span><span class="token operator">=</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 记录后移 </span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span>dk<span class="token punctuation">]</span><span class="token operator">=</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 插入正确的位置 </span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//对顺序表L中的记录按增量序列（存储在数组dt中）进行t趟希尔排序</span><span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> dt<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//请补充该操作</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>t<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">ShellInsert</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>dt<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 一趟增量为dt[k]的希尔插入排序 </span><span class="token punctuation">}</span></code></pre><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>基本思想：对待排序序列按照从前向后的顺序，依次比较相邻记录的关键字，若发现逆序则交换，使关键字较大的记录逐渐向后移动（从下标较小的单元移向下标较大的单元）。</p><p>排序过程：（假设记录保存在顺序表L中）</p><ul><li>初始：<code>L.r[1..n]</code>为无序区。</li><li>第一趟排序（无序区为<code>L.r[1..n]</code>）<ul><li>从左到右扫描无序区，依次比较相邻两个记录关键字的值，若发现“前大后小”，则交换二者的位置。即依次比较<code>(L.r[1]，L.r [2])，(L.r[2]，L.r [3])，…，(L.r[n-1]，L.r [n])</code> 对于没对记录<code>(L.r[j]，L.r [j+1])</code>若<code>L.r [j].key&gt;L.r [j+1].key</code>，则交换<code>L.r [j]</code>和<code>L.r [j+1]</code>的内容。</li><li>第一趟排序完毕时，最大的关键字就下沉到该区间的底部，即<code>L.r[n]</code>的位置。</li><li>第二趟排序（无序区为<code>L.r [1..n-1]</code> ，有序区为<code>L.r [n]</code>)</li><li>第<code>i</code>趟排序 （无序区为<code>L.r [1..n-1]</code> ，有序区为<code>L.r [n]</code>扫描<code>L.r [1..n-1]</code>，扫描完毕时，次大的关键字下沉到<code>L.r [n-1]</code>的位置</li><li>经过<code>n-1</code>趟排序后，无序区为<code>L.r [1]</code>，有序区为<code>L.r [2...n]</code>排序完成</li><li>若第i趟排序过程中，没有进行任何记录交换，则表明 <code>L.r [1..n-i+1]</code>中的记录已经有序，因此不再需要进行下一趟的排序，即冒泡排序已经完成。即：排序结束的条件是(i=n-1)或者某趟的排序过程中没有进行记录交换。</li></ul></li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//对顺序表L中的记录进行冒泡排序</span><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//请补充该操作</span>    <span class="token keyword">int</span> flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>L<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>flag<span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 控制排序趟数</span>        flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 每趟排序开始时，将flag</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 从前向后扫描本趟无序区[1...i+1]</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">></span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 若相邻记录是逆序，交换之</span>                flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 本趟排序中发生了交换，将flag置为1</span>                RedType t<span class="token operator">=</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                  L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>t<span class="token punctuation">;</span>              <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>排序过程</p><p><img src="DataStrucBubbleAnim.gif" alt="DataStrucBubbleAnim"></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序（<code>Quick Sorting</code>)是所有内部排序算法中速度最快的一种排序算法</p><p>基本思想：任取待排序序列中的某个记录作为枢轴（一般取第一个记录），通过一趟排序（一次划分），将待排序记录分为左右两个子序列，左子序列中记录的关键字均小于或等于枢轴记录的关键字，右子序列中记录的关键字均大于枢轴记录的关键字，然后分别对两个子序列进行快速排序，直至整个序列有序。</p><p>排序过程：对顺序表<code>L</code>中记录进行一趟快速排序，附设两个指针<code>low</code>和<code>high</code>，设枢轴记录关键字为<code>pivotkey</code>，初始时令<code>low=1,high=L.length</code>，<code>pivotkey=L.r[1].key</code></p><ul><li>首先从high所指位置向前搜索第一个关键字小于枢轴的记录，令<code>L.r[low]=L.r[high]</code>，使关键字相对较小的记录交换到左子序列中。</li><li>再从<code>low</code>所指位置起向后搜索，找第一个关键字大于枢轴的记录，令<code>L.r[high]=L.r[row]</code>，使关键字相对于较大的记录交换到右子序列中。<br>重复上述两步，直至<code>low=high</code>为止，此位置就是枢轴记录最终被存放的记录的位置。<br>在分别对两个子序列进行快速排序，<strong>直到每个子序列只含一个记录为止</strong></li></ul><p>排序过程</p><p><img src="DataStrucQuickSortAnim.gif" alt="DataStrucQuickSortAnim"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子DIV块中设置margin-top时影响父DIV块位置问题</title>
      <link href="/2019/05/06/webtipsinfluenceofinner-sdivmagintop/"/>
      <url>/2019/05/06/webtipsinfluenceofinner-sdivmagintop/</url>
      
        <content type="html"><![CDATA[<h2 id="贴出代码"><a href="#贴出代码" class="headerlink" title="贴出代码"></a>贴出代码</h2><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token id">#outer</span></span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#000</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token id">#inner</span></span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#fff</span><span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span>&lt;div id=<span class="token string">"outer"</span>>    &lt;div id=<span class="token string">"inner"</span>>&lt;/div>&lt;/div></code></pre><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="WebTipsMarginTop.png" alt="WebTipsMarginTop"><br>但是实际情况，我们期望的是<br><img src="WebTipsMarginTop2.png" alt="WebTipsMarginTop"></p><p>为什么为产生这样的效果<br>原因来自于<code>css</code>盒模型<code>margin</code>合并的问题</p><p>第一种解释</p><blockquote><p>In this specification, the expression collapsing margins means that adjoining margins (no non-empty content, padding or border areas or clearance separate them) of two or more boxes (which may be next to one another or nested) combine to form a single margin. 所有毗邻的两个或更多盒元素的margin将会合并为一个margin共享之。毗邻的定义为：同级或者嵌套的盒元素，并且它们之间没有非空内容、Padding或Border分隔。</p></blockquote><p>第二种解释</p><blockquote><p>块级元素的垂直相邻外边距会合并。</p></blockquote><p>结合一下，就是说，<code>子DIV</code>和<code>父DIV</code>因为是毗邻的关系让<code>子DIV</code>的<code>margin-top</code>影响到了<code>父DIV</code></p><p>解决方案</p><ul><li>将父级over-flow设为hidden</li><li>将父级display设为inline-block</li><li>将父级float或absolute</li><li>改变父级的结构</li><li>给父元素设置padding</li><li>给父元素设置透明border</li></ul><blockquote><p><a href="https://blog.csdn.net/hahhahahaa/article/details/80676873" target="_blank" rel="noopener">https://blog.csdn.net/hahhahahaa/article/details/80676873</a><br><a href="https://blog.csdn.net/man_tutu/article/details/54987177" target="_blank" rel="noopener">https://blog.csdn.net/man_tutu/article/details/54987177</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DIV+CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈弗曼树深入浅出</title>
      <link href="/2019/04/24/datastructhuffmantree/"/>
      <url>/2019/04/24/datastructhuffmantree/</url>
      
        <content type="html"><![CDATA[<h2 id="哈夫满树的基本概念"><a href="#哈夫满树的基本概念" class="headerlink" title="哈夫满树的基本概念"></a>哈夫满树的基本概念</h2><p><strong>哈夫曼<code>(HuffMan)</code></strong>树又称<strong>最优树</strong>，是一类带权路径长度最短的树。</p><ol><li><strong>路径</strong>：从树中的一个结点到另一个结点之间分支构成这两个结点之间的路径。</li><li><strong>路径长度</strong>：路径上的分支数目称作路径长度。</li><li><strong>树的路径长度</strong>：从树根到每一结点的路径长度之和。</li><li><strong>权</strong>：赋予某一个实体的一个量，是对实体的某个或某些属性的数值化描述</li><li>结点的带权路径长度：从该结点到树根之间的路径长度与结点上权的乘积。</li><li><strong>树的带权路径长度</strong>：树中所有<font color="red">叶子结点</font>的带权路径长度之和，通常记为 $WPL= \sum_{k=0}^{n}w_il_k $</li><li><strong>哈夫曼树</strong>：假设有<code>m</code>个权值${w_1,w_2,…,w_m}$，可以构造一棵含n个叶子结点的二叉树，每个叶子结点的权为$w_i$，则其中带权路径长度<code>WPL</code>最小二叉树称做最优二叉树或者哈夫曼树</li></ol><p><img src="DataStructHFP.jpg" alt="哈夫曼树图"></p><h2 id="哈夫曼树的构造算法"><a href="#哈夫曼树的构造算法" class="headerlink" title="哈夫曼树的构造算法"></a>哈夫曼树的构造算法</h2><ol><li>哈夫曼树的构造过程<ul><li>给定n个权值${w_1,w_2,…,w_m}$，构造n棵只有根结点的二叉树，这n课二叉树构成了一个森林F。</li><li>在森林里F中选择两棵根结点的权值<strong>最小</strong>的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和</li><li>在森林F中删除这两棵树，同时将新得到的二叉树加入F中。</li><li>一直重复<font color="red">第二句</font>和<font color="red">第三句</font>，直到<code>F</code>只含一棵树为止。这个数便是哈夫曼树。</li></ul></li></ol><p><font color="red">在构造哈夫曼树时，首先选择权小的，这样保证权大的离根很近，这样一来，在计算树的带权路径长度时候，自然会得到最小带权路径长度，这种算法是一种典型的<strong>贪心法</strong></font><br><img src="DataStructHFP2.jpg" alt="哈夫曼树图"></p><h3 id="哈夫曼算法的实现"><a href="#哈夫曼算法的实现" class="headerlink" title="哈夫曼算法的实现"></a>哈夫曼算法的实现</h3><p>哈夫曼树结点形式</p><table><thead><tr><th align="center">权重</th><th align="center">父结点</th><th align="center">左儿子</th><th align="center">右儿子</th></tr></thead><tbody><tr><td align="center">weight</td><td align="center">parent</td><td align="center">lchild</td><td align="center">rchild</td></tr></tbody></table><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">CreateHuffmanTree</span><span class="token punctuation">(</span>HuffmanTree <span class="token operator">&amp;</span>HT<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 构建哈夫曼树HT</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>m<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token number">-1</span><span class="token punctuation">,</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 为什么m=2n-1 因为哈夫曼树没有度为1的结点 </span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    HT<span class="token operator">=</span><span class="token punctuation">(</span>HuffmanTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>HTNode<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 0号单元未用，所以需要动态分配m+1个单元，HT[m]表示根结点</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 将1~m号单元中的双亲，左孩子，右孩子的下标都初始化为0 </span>        HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rchild<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"==============HF的初态==============\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TraverHiffmanTreeData</span><span class="token punctuation">(</span>HT<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/*==================初始化工作结束=====================*/</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">Select</span><span class="token punctuation">(</span>HT<span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">,</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 在HT[k](1&lt;=K&lt;=K-1)中选择两个其双亲域为0且权值最小的结点</span>        <span class="token comment" spellcheck="true">// 并返回它们在HT中的序号s1和s2</span>        HT<span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">=</span>i<span class="token punctuation">;</span>        HT<span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">=</span>i<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 得到新结点i，从森林中删除s1，s2，将s1和s2的双区域从0改为i</span>        HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild<span class="token operator">=</span>s1<span class="token punctuation">;</span>        HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rchild<span class="token operator">=</span>s2<span class="token punctuation">;</span>        HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">=</span>HT<span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">+</span>HT<span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>关于<code>CreateHuffmanTree</code>的一些问题  </p><ul><li><strong>Q：为什么<code>m=2n-1</code> 因为哈夫曼树没有度为1的结点</strong><br>A：因为哈夫曼树选择两颗权值最小的子树作为孩子结点构造新的二叉树，这就造成了，哈夫曼树不会有度为1的结点，所以根据有<code>n</code>个叶子结点，也就得出了总共有<code>2n-1(根结点)</code>个总结点。  </li><li><strong>Q：申请的空间为什么是<code>m+1</code>，而遍历的时候却是用<code>m</code></strong><br>A：因为申请的空间相当于一个数组，下标为0开始。例如，当传入的值为8的时候，申请到<code>15*sizeof(HTNode)</code>个位置，也就是<code>0~14</code>，对于计算其实不方便，于是就多申请了一个空间<code>m+1</code>，申请到了<code>16*sizeof(HTNode)</code>，也就是<code>0~15</code>，这样就可以使用下标为1开始一直到15或者<code>m</code>的位置了。  </li><li>*<em>Q：<code>for</code>循环中<code>i=n+1</code>和<code>Select(HT,i-1,s1,s2);</code>，i的变量该如何理解？  *</em><br>A：第一个i其实是从前n个结点的下一个结点开始存储新构造的二叉树的根节点，第二个i值，是<font color="red">动态</font>的变化当前一共有多少个结点可以进行选择最小权值，也就是<code>i-1</code></li></ul><hr><p><code>Select</code>方法</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Select</span><span class="token punctuation">(</span>HuffmanTree HT<span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>min1<span class="token operator">=</span><span class="token number">0x3f3f3f3f</span><span class="token punctuation">,</span>min2<span class="token operator">=</span><span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 先赋予最大值</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">&lt;</span>min1<span class="token operator">&amp;&amp;</span>HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 选出所有权重最小的权重，且没有双亲结点</span>            <span class="token comment" spellcheck="true">// 擂台算法</span>            min1<span class="token operator">=</span>HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>            s1<span class="token operator">=</span>i<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// s1纪录第1小的位置</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> temp<span class="token operator">=</span>HT<span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>    HT<span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">=</span><span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将原值存放起来，然后先赋予最大值，防止s1被重复选择</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">&lt;</span>min2<span class="token operator">&amp;&amp;</span>HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            min2<span class="token operator">=</span>HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 擂台算法权重最小的权重，且没有双亲结点</span>            <span class="token comment" spellcheck="true">// 选取所有结点</span>            s2<span class="token operator">=</span>i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    HT<span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">=</span>temp<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 恢复原来的值</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"s1位置：%d，s1的值：%d，s2的位置%d，s2的值：%d\n"</span><span class="token punctuation">,</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">,</span>HT<span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">,</span>HT<span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>关于<code>Select</code>方法的一个问题  </p><ul><li><strong>Q：如何选取两个权值最小的结点？</strong><br>A：通过两个条件，一是<code>HT[i].weight&lt;min1</code>，也就是擂台算法，选取数组中一个最小值，二是<code>&amp;HT[i].parent==0</code>这样就不会选取已经称为树的结点的结点，其中第一次选择的最小值，可能第二次还有可能选择，于是就先用临时变量保存以下，然后把当前第一次选择的最小值置为一个最大值，这样第二次就不会再次选到第一次选择的值了。</li></ul><hr><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// TraverseTree方法</span><span class="token keyword">void</span> <span class="token function">TraverHiffmanTreeData</span><span class="token punctuation">(</span>HuffmanTree HF<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"结点i    weight    parent    lchild    rchild\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>HF<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">&lt;</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d    %d    %d    %d    %d\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>HF<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">,</span>HF<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">,</span>HF<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild<span class="token punctuation">,</span>HF<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d    -    %d    %d    %d\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>HF<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">,</span>HF<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild<span class="token punctuation">,</span>HF<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><h2 id="完整程序"><a href="#完整程序" class="headerlink" title="完整程序"></a>完整程序</h2><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token comment" spellcheck="true">// ---- 哈夫曼树的存储表示 ----- </span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> weight<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 结点的权值</span>    <span class="token keyword">int</span> parent<span class="token punctuation">,</span>lchild<span class="token punctuation">,</span>rchild<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 结点的双亲、左孩子、右孩子的下标 </span><span class="token punctuation">}</span>HTNode<span class="token punctuation">,</span><span class="token operator">*</span>HuffmanTree<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 动态分配数组存储哈夫曼树</span><span class="token keyword">void</span> <span class="token function">Select</span><span class="token punctuation">(</span>HuffmanTree HT<span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>min1<span class="token operator">=</span><span class="token number">0x3f3f3f3f</span><span class="token punctuation">,</span>min2<span class="token operator">=</span><span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 先赋予最大值</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">&lt;</span>min1<span class="token operator">&amp;&amp;</span>HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 选出所有权重最小的权重，且没有双亲结点</span>            <span class="token comment" spellcheck="true">// 擂台算法 </span>            min1<span class="token operator">=</span>HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>            s1<span class="token operator">=</span>i<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// s1纪录第1小的位置 </span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> temp<span class="token operator">=</span>HT<span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>    HT<span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">=</span><span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将原值存放起来，然后先赋予最大值，防止s1被重复选择</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">&lt;</span>min2<span class="token operator">&amp;&amp;</span>HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            min2<span class="token operator">=</span>HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 擂台算法权重最小的权重，且没有双亲结点 </span>            <span class="token comment" spellcheck="true">// 选取所有结点 </span>            s2<span class="token operator">=</span>i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    HT<span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">=</span>temp<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 恢复原来的值</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"s1位置：%d，s1的值：%d，s2的位置%d，s2的值：%d\n"</span><span class="token punctuation">,</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">,</span>HT<span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">,</span>HT<span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">TraverHiffmanTreeData</span><span class="token punctuation">(</span>HuffmanTree HF<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"结点i    weight    parent    lchild    rchild\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>HF<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">&lt;</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d    %d    %d    %d    %d\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>HF<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">,</span>HF<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">,</span>HF<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild<span class="token punctuation">,</span>HF<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d    -    %d    %d    %d\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>HF<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">,</span>HF<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild<span class="token punctuation">,</span>HF<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">CreateHuffmanTree</span><span class="token punctuation">(</span>HuffmanTree <span class="token operator">&amp;</span>HT<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 构建哈夫曼树HT</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>m<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token number">-1</span><span class="token punctuation">,</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 为什么m=2n-1 因为哈夫曼树没有度为1的结点 </span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    HT<span class="token operator">=</span><span class="token punctuation">(</span>HuffmanTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>HTNode<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 0号单元未用，所以需要动态分配m+1个单元，HT[m]表示根结点</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 将1~m号单元中的双亲，左孩子，右孩子的下标都初始化为0 </span>        HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rchild<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"==============HF的初态==============\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TraverHiffmanTreeData</span><span class="token punctuation">(</span>HT<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/*==================初始化工作结束=====================*/</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">Select</span><span class="token punctuation">(</span>HT<span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">,</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 在HT[k](1&lt;=K&lt;=K-1)中选择两个其双亲域为0且权值最小的结点</span>        <span class="token comment" spellcheck="true">// 并返回它们在HT中的序号s1和s2</span>        HT<span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">=</span>i<span class="token punctuation">;</span>        HT<span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">=</span>i<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 得到新结点i，从森林中删除s1，s2，将s1和s2的双区域从0改为i</span>        HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild<span class="token operator">=</span>s1<span class="token punctuation">;</span>        HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rchild<span class="token operator">=</span>s2<span class="token punctuation">;</span>        HT<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">=</span>HT<span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">+</span>HT<span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 数据 5 29 7 8 14 23 3 11 </span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    HuffmanTree HF<span class="token punctuation">;</span>    <span class="token function">CreateHuffmanTree</span><span class="token punctuation">(</span>HF<span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"==============HF的终态==============\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TraverHiffmanTreeData</span><span class="token punctuation">(</span>HF<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> </code></pre><p>程序最终运行结果<br><img src="https://www.haczz.xyz/img/temp/DataStructHiffmanTreeResult.png" alt="运行结果"></p><blockquote><p>数据结构[C语言版] 严蔚敏 李冬梅 吴伟民</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈夫曼树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReView关系数据库标准语言SQL查询语句</title>
      <link href="/2019/04/21/databasereviewsql/"/>
      <url>/2019/04/21/databasereviewsql/</url>
      
        <content type="html"><![CDATA[<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="XmindSQL.jpg" alt=""></p><h2 id="表格数据准备"><a href="#表格数据准备" class="headerlink" title="表格数据准备"></a>表格数据准备</h2><h3 id="SC表"><a href="#SC表" class="headerlink" title="SC表"></a>SC表</h3><table><thead><tr><th align="center">Sno</th><th align="center">Cno</th><th align="center">Grade</th></tr></thead><tbody><tr><td align="center">200215121</td><td align="center">1</td><td align="center">92</td></tr><tr><td align="center">200215121</td><td align="center">2</td><td align="center">54</td></tr><tr><td align="center">200215121</td><td align="center">3</td><td align="center">88</td></tr><tr><td align="center">200215122</td><td align="center">2</td><td align="center">57</td></tr><tr><td align="center">200215122</td><td align="center">3</td><td align="center">80</td></tr></tbody></table><h3 id="Student表"><a href="#Student表" class="headerlink" title="Student表"></a>Student表</h3><table><thead><tr><th align="center">Sno</th><th align="center">Sname</th><th align="center">Ssex</th><th align="center">Sage</th><th align="center">Sdept</th></tr></thead><tbody><tr><td align="center">200215121</td><td align="center">李勇</td><td align="center">男</td><td align="center">20</td><td align="center">CS</td></tr><tr><td align="center">200215122</td><td align="center">刘晨</td><td align="center">女</td><td align="center">19</td><td align="center">CS</td></tr><tr><td align="center">200215123</td><td align="center">王敏</td><td align="center">女</td><td align="center">23</td><td align="center">MA</td></tr><tr><td align="center">200215125</td><td align="center">张立</td><td align="center">男</td><td align="center">19</td><td align="center">IS</td></tr><tr><td align="center">200215126</td><td align="center">张红</td><td align="center">女</td><td align="center">19</td><td align="center">CS</td></tr></tbody></table><h3 id="Course表"><a href="#Course表" class="headerlink" title="Course表"></a>Course表</h3><table><thead><tr><th align="center">Cno</th><th align="center">Cname</th><th align="center">Cpno</th><th align="center">Ccredit</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">数据库</td><td align="center">5</td><td align="center">4</td></tr><tr><td align="center">2</td><td align="center">数学</td><td align="center">NULL</td><td align="center">4</td></tr><tr><td align="center">3</td><td align="center">信息系统</td><td align="center">1</td><td align="center">4</td></tr><tr><td align="center">4</td><td align="center">操作系统</td><td align="center">6</td><td align="center">3</td></tr><tr><td align="center">5</td><td align="center">数据结构</td><td align="center">7</td><td align="center">4</td></tr><tr><td align="center">6</td><td align="center">数据处理</td><td align="center">NULL</td><td align="center">2</td></tr><tr><td align="center">7</td><td align="center">PASCAL语言</td><td align="center">6</td><td align="center">2</td></tr><tr><td align="center">8</td><td align="center">Visual_Basic</td><td align="center">NULL</td><td align="center">4</td></tr></tbody></table><h2 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h2><h3 id="聚集函数、GROUP-BY、HAVING"><a href="#聚集函数、GROUP-BY、HAVING" class="headerlink" title="聚集函数、GROUP BY、HAVING"></a>聚集函数、GROUP BY、HAVING</h3><ul><li>GROUP BY子句将查询结果按一列或多列的值分组，值相等的为一组</li><li>对查询结果分组的目的是为了细化聚集函数的作用对象</li><li>分组后聚集函数将作用与每一个组，既每一个组都有一个函数值。</li></ul><hr><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> Cno<span class="token punctuation">,</span><span class="token function">COUNT</span><span class="token punctuation">(</span>Sno<span class="token punctuation">)</span> 选课人数 <span class="token keyword">from</span> SC <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Cno<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 对Cno进行分组，将所有的Cno值的元组为一组，然后对每组作用聚集函数COUNT进行计算</span><span class="token comment" spellcheck="true">-- 以求得课程号及相应的选课人数</span></code></pre><table><thead><tr><th align="center">Cno</th><th align="center">选课人数</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">3</td><td align="center">2</td></tr></tbody></table><hr><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> Sno <span class="token keyword">FROM</span> SC <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Sno <span class="token keyword">HAVING</span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 这里先用GROUP BY子句按Sno进行分组，再用聚集函数COUNT对每一组计数；</span><span class="token comment" spellcheck="true">-- HAVING短语给出了选择组的条件，只有满足了条件的组才能选出来</span><span class="token comment" spellcheck="true">-- 分组后还要求按一定条件对这些组进行筛选[用HAVING]，最终只输出满足指定条件的组。</span></code></pre><table><thead><tr><th align="center">Sno</th></tr></thead><tbody><tr><td align="center">200215121</td></tr></tbody></table><hr><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 例子</span><span class="token keyword">SELECT</span> Sno<span class="token punctuation">,</span><span class="token function">AVG</span><span class="token punctuation">(</span>Grade<span class="token punctuation">)</span> 平均分 <span class="token keyword">FROM</span> SC <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Sno <span class="token keyword">HAVING</span> <span class="token function">AVG</span><span class="token punctuation">(</span>Grade<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">55</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 先用GROUP BY将Sno进行分组，在用平均函数算出每一组的平均数</span><span class="token comment" spellcheck="true">-- HAVING短语给出了条件，只有平均值大于55的一组才被查询出来</span><span class="token comment" spellcheck="true">-- 这个地方不能用where</span></code></pre><table><thead><tr><th align="center">Sno</th><th align="center">平均分</th></tr></thead><tbody><tr><td align="center">200215121</td><td align="center">78</td></tr><tr><td align="center">200215122</td><td align="center">68</td></tr></tbody></table><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><h4 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h4><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 等值连接</span><span class="token comment" spellcheck="true">--查询SC表所有在Student表中的信息</span><span class="token keyword">SELECT</span> Student<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span>SC<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> Student<span class="token punctuation">,</span>SC <span class="token keyword">WHERE</span> Student<span class="token punctuation">.</span>Sno<span class="token operator">=</span>SC<span class="token punctuation">.</span>Sno<span class="token punctuation">;</span></code></pre><table><thead><tr><th>Sno</th><th>Sname</th><th>Ssex</th><th>Sage</th><th>Sdept</th><th>Sno</th><th>Cno</th><th>Grade</th></tr></thead><tbody><tr><td>200215121</td><td>李勇</td><td>男</td><td>20</td><td>CS</td><td>200215121</td><td>1</td><td>92</td></tr><tr><td>200215121</td><td>李勇</td><td>男</td><td>20</td><td>CS</td><td>200215121</td><td>2</td><td>54</td></tr><tr><td>200215121</td><td>李勇</td><td>男</td><td>20</td><td>CS</td><td>200215121</td><td>3</td><td>88</td></tr><tr><td>200215122</td><td>刘晨</td><td>女</td><td>19</td><td>CS</td><td>200215122</td><td>2</td><td>57</td></tr><tr><td>200215122</td><td>刘晨</td><td>女</td><td>19</td><td>CS</td><td>200215122</td><td>3</td><td>80</td></tr></tbody></table><hr><h4 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h4><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 自然连接</span><span class="token keyword">SELECT</span> Student<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span>SC<span class="token punctuation">.</span>Cno<span class="token punctuation">,</span>SC<span class="token punctuation">.</span>Grade <span class="token keyword">FROM</span> Student<span class="token punctuation">,</span>SC <span class="token keyword">WHERE</span> Student<span class="token punctuation">.</span>Sno<span class="token operator">=</span>SC<span class="token punctuation">.</span>Sno<span class="token punctuation">;</span></code></pre><table><thead><tr><th align="center">Sno</th><th align="center">Sname</th><th align="center">Ssex</th><th align="center">Sage</th><th align="center">Sdept</th><th align="center">Cno</th><th align="center">Grade</th></tr></thead><tbody><tr><td align="center">200215121</td><td align="center">李勇</td><td align="center">男</td><td align="center">20</td><td align="center">CS</td><td align="center">1</td><td align="center">92</td></tr><tr><td align="center">200215121</td><td align="center">李勇</td><td align="center">男</td><td align="center">20</td><td align="center">CS</td><td align="center">2</td><td align="center">54</td></tr><tr><td align="center">200215121</td><td align="center">李勇</td><td align="center">男</td><td align="center">20</td><td align="center">CS</td><td align="center">3</td><td align="center">88</td></tr><tr><td align="center">200215122</td><td align="center">刘晨</td><td align="center">女</td><td align="center">19</td><td align="center">CS</td><td align="center">2</td><td align="center">57</td></tr><tr><td align="center">200215122</td><td align="center">刘晨</td><td align="center">女</td><td align="center">19</td><td align="center">CS</td><td align="center">3</td><td align="center">80</td></tr></tbody></table><hr><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 外连接</span><span class="token keyword">SELECT</span> Student<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span>SC<span class="token punctuation">.</span>Cno<span class="token punctuation">,</span>SC<span class="token punctuation">.</span>Grade <span class="token keyword">FROM</span> Student <span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> SC <span class="token keyword">ON</span><span class="token punctuation">(</span>Student<span class="token punctuation">.</span>Sno<span class="token operator">=</span>SC<span class="token punctuation">.</span>Sno<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><table><thead><tr><th align="center">Sno</th><th align="center">Sname</th><th align="center">Ssex</th><th align="center">Sage</th><th align="center">Sdept</th><th align="center">Cno</th><th align="center">Grade</th></tr></thead><tbody><tr><td align="center">200215121</td><td align="center">李勇</td><td align="center">男</td><td align="center">20</td><td align="center">CS</td><td align="center">1</td><td align="center">92</td></tr><tr><td align="center">200215121</td><td align="center">李勇</td><td align="center">男</td><td align="center">20</td><td align="center">CS</td><td align="center">2</td><td align="center">54</td></tr><tr><td align="center">200215121</td><td align="center">李勇</td><td align="center">男</td><td align="center">20</td><td align="center">CS</td><td align="center">3</td><td align="center">88</td></tr><tr><td align="center">200215122</td><td align="center">刘晨</td><td align="center">女</td><td align="center">19</td><td align="center">CS</td><td align="center">2</td><td align="center">57</td></tr><tr><td align="center">200215122</td><td align="center">刘晨</td><td align="center">女</td><td align="center">19</td><td align="center">CS</td><td align="center">3</td><td align="center">80</td></tr><tr><td align="center">200215123</td><td align="center">王敏</td><td align="center">女</td><td align="center">23</td><td align="center">MA</td><td align="center">NULL</td><td align="center">NULL</td></tr><tr><td align="center">200215125</td><td align="center">张立</td><td align="center">男</td><td align="center">19</td><td align="center">IS</td><td align="center">NULL</td><td align="center">NULL</td></tr><tr><td align="center">200215126</td><td align="center">张红</td><td align="center">女</td><td align="center">19</td><td align="center">CS</td><td align="center">NULL</td><td align="center">NULL</td></tr></tbody></table><hr><h4 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h4><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 多表连接</span><span class="token keyword">SELECT</span> Student<span class="token punctuation">.</span>Sno<span class="token punctuation">,</span>Sname<span class="token punctuation">,</span>Cname<span class="token punctuation">,</span>Grade <span class="token keyword">FROM</span> Student<span class="token punctuation">,</span>SC<span class="token punctuation">,</span>Course <span class="token keyword">WHERE</span> Student<span class="token punctuation">.</span>Sno<span class="token operator">=</span>SC<span class="token punctuation">.</span>Sno <span class="token operator">AND</span> SC<span class="token punctuation">.</span>Cno<span class="token operator">=</span>Course<span class="token punctuation">.</span>Cno<span class="token punctuation">;</span></code></pre><table><thead><tr><th align="center">Sno</th><th align="center">Sname</th><th align="center">Cname</th><th align="center">Grade</th></tr></thead><tbody><tr><td align="center">200215121</td><td align="center">李勇</td><td align="center">数据库</td><td align="center">92</td></tr><tr><td align="center">200215121</td><td align="center">李勇</td><td align="center">数学</td><td align="center">54</td></tr><tr><td align="center">200215121</td><td align="center">李勇</td><td align="center">信息系统</td><td align="center">88</td></tr><tr><td align="center">200215122</td><td align="center">刘晨</td><td align="center">数学</td><td align="center">57</td></tr><tr><td align="center">200215122</td><td align="center">刘晨</td><td align="center">信息系统</td><td align="center">80</td></tr></tbody></table><hr><h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>在SQL语言中，一个<code>SELECT-FROM-WHERE</code>的语句称为一个查询块。将一个查询块嵌套在另一个查询块的<code>WHERE</code>子句或<code>HAVING</code>短语的条件中的查询称为嵌套查询（nested query）</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 带有IN的子查询</span><span class="token keyword">SELECT</span> Sname <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Sno <span class="token operator">IN</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> Sno <span class="token keyword">FROM</span> SC <span class="token keyword">WHERE</span> Cno<span class="token operator">=</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 不相关子查询</span><span class="token comment" spellcheck="true">-- 此查询语句意味这查出选修课选修了二号课程的学生姓名</span></code></pre><p>先执行内查询<code>SELECT Sno FROM SC WHERE Cno='2'</code>找到选修了二号课程的学生</p><table><thead><tr><th align="center">Sno</th></tr></thead><tbody><tr><td align="center">200215121</td></tr><tr><td align="center">200215122</td></tr></tbody></table><p>在通过内查询的结果执行<code>SELECT Sname FROM Student WHERE Sno IN(内查询结果)</code>，查询选修了二号课程学生的姓名</p><table><thead><tr><th align="center">Sname</th></tr></thead><tbody><tr><td align="center">李勇</td></tr><tr><td align="center">刘晨</td></tr></tbody></table><hr><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 带有IN的子查询</span><span class="token keyword">SELECT</span> Sno<span class="token punctuation">,</span>Sname<span class="token punctuation">,</span>Sdept <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Sdept <span class="token operator">IN</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> Sdept <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Sname<span class="token operator">=</span><span class="token string">'刘晨'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 不相关子查询</span></code></pre><p>先执行内查询<code>SELECT Sdept FROM Student WHERE Sname='刘晨'</code>找到刘晨的系别</p><table><thead><tr><th align="center">Sdept</th></tr></thead><tbody><tr><td align="center">CS</td></tr></tbody></table><p>再执行外查询<code>SELECT Sno,Sname,Sdept FROM Student WHERE Sdept IN(内查询结果)</code>，查询再<code>Student</code>表中系别和刘晨系别一样的同学学号，姓名，系别</p><table><thead><tr><th align="center">Sno</th><th align="center">Sname</th><th align="center">Sdept</th></tr></thead><tbody><tr><td align="center">200215121</td><td align="center">李勇</td><td align="center">CS</td></tr><tr><td align="center">200215122</td><td align="center">刘晨</td><td align="center">CS</td></tr><tr><td align="center">200215126</td><td align="center">张红</td><td align="center">CS</td></tr></tbody></table><hr><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--- 同理，不再展示结果了</span><span class="token keyword">SELECT</span> Sno<span class="token punctuation">,</span>Sname <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Sno <span class="token operator">IN</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> Sno <span class="token keyword">FROM</span> SC <span class="token keyword">WHERE</span> Cno <span class="token operator">IN</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> Cno <span class="token keyword">FROM</span> Course <span class="token keyword">WHERE</span> Cname<span class="token operator">=</span><span class="token string">'信息系统'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 不相关子查询</span><span class="token comment" spellcheck="true">-- 带有比较运算符的子查询</span></code></pre><hr><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--- 带有比较字符的子查询</span><span class="token keyword">SELECT</span> Sno<span class="token punctuation">,</span>Sname<span class="token punctuation">,</span>Sdept <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Sdept<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> Sdept <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Sname<span class="token operator">=</span><span class="token string">'刘晨'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><table><thead><tr><th align="center">Sno</th><th align="center">Sname</th><th align="center">Sdept</th></tr></thead><tbody><tr><td align="center">200215121</td><td align="center">李勇</td><td align="center">CS</td></tr><tr><td align="center">200215122</td><td align="center">刘晨</td><td align="center">CS</td></tr><tr><td align="center">200215126</td><td align="center">张红</td><td align="center">CS</td></tr></tbody></table><hr><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 相关子查询</span><span class="token keyword">SELECT</span> Sno<span class="token punctuation">,</span>Cno <span class="token keyword">FROM</span> SC x <span class="token keyword">WHERE</span> Grade<span class="token operator">>=</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>Grade<span class="token punctuation">)</span> <span class="token keyword">FROM</span> SC y <span class="token keyword">WHERE</span> Y<span class="token punctuation">.</span>Sno<span class="token operator">=</span>x<span class="token punctuation">.</span>Sno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 从外层查询中取出SC的一个元组x，将元组x的Sno值（201215121）传送给内层查询</span><span class="token comment" spellcheck="true">-- 执行内层查询，得到值,用该值代替内层查询，得到外层查询</span><span class="token comment" spellcheck="true">-- 然后外层查询取出下一个元组重复做上述步骤的处理，直到外层的SC元组全部处理完毕。</span></code></pre><table><thead><tr><th align="center">Sno</th><th align="center">Cno</th></tr></thead><tbody><tr><td align="center">200215121</td><td align="center">1</td></tr><tr><td align="center">200215121</td><td align="center">3</td></tr><tr><td align="center">200215122</td><td align="center">3</td></tr></tbody></table><hr><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 带有ANY(SOME)或ALL谓词的子查询</span><span class="token keyword">SELECT</span> Sname<span class="token punctuation">,</span>Sage <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Sage<span class="token operator">&lt;</span><span class="token keyword">ANY</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> Sage <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Sdept<span class="token operator">=</span><span class="token string">'CS'</span><span class="token punctuation">)</span> <span class="token operator">AND</span> Sdept<span class="token operator">&lt;></span><span class="token string">'CS'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 查询在Student表中大于任意一个CS系同学年龄的一条元组并且，这个同学不能是计科系的</span></code></pre><table><thead><tr><th align="center">Sname</th><th align="center">Sage</th></tr></thead><tbody><tr><td align="center">张立</td><td align="center">19</td></tr></tbody></table><hr><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 用聚集函数</span><span class="token keyword">SELECT</span> Sname<span class="token punctuation">,</span>Sage <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Sage<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>Sage<span class="token punctuation">)</span><span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Sdept<span class="token operator">=</span><span class="token string">'CS'</span><span class="token punctuation">)</span> <span class="token operator">AND</span> Sdept <span class="token operator">&lt;></span><span class="token string">'CS'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Sname<span class="token punctuation">,</span>Sage <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Sage<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">MIN</span><span class="token punctuation">(</span>Sage<span class="token punctuation">)</span><span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Sdept<span class="token operator">=</span><span class="token string">'CS'</span><span class="token punctuation">)</span><span class="token operator">AND</span> Sdept<span class="token operator">&lt;></span><span class="token string">'CS'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 第二句表格是空的，因为没有符合条件的数据</span></code></pre><table><thead><tr><th align="center">Sname</th><th align="center">Sage</th></tr></thead><tbody><tr><td align="center">张立</td><td align="center">19</td></tr></tbody></table><hr><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> Sname <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> SC <span class="token keyword">WHERE</span> Sno<span class="token operator">=</span>Student<span class="token punctuation">.</span>Sno <span class="token operator">AND</span> Cno<span class="token operator">=</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 查询所有选修1号课程的学生姓名</span><span class="token comment" spellcheck="true">-- 本查询涉及Student和SC关系</span><span class="token comment" spellcheck="true">-- 在Student中依次取每个元组的Sno值，用此值去检查SC表</span><span class="token comment" spellcheck="true">-- 若SC中存在这样的元组,其Sno值等于此Student.Sno值，并且其Cno='1'，则取此Student.Sname送入结果表</span></code></pre><table><thead><tr><th align="center">Sname</th></tr></thead><tbody><tr><td align="center">李勇</td></tr></tbody></table><hr><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 查询没有选修1号课程的学生姓名。</span><span class="token keyword">SELECT</span> Sname <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> SC <span class="token keyword">WHERE</span> Sno<span class="token operator">=</span>Student<span class="token punctuation">.</span>Sno <span class="token operator">AND</span> Cno<span class="token operator">=</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><table><thead><tr><th align="center">Sname</th></tr></thead><tbody><tr><td align="center">刘晨</td></tr><tr><td align="center">王敏</td></tr><tr><td align="center">张立</td></tr><tr><td align="center">张红</td></tr></tbody></table><hr><p>EXISTS量词待理解</p><hr><h5 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h5><p>集合查询包括并操作<code>UNION</code>、交操作<code>INTERSECT</code>和差操作<code>EXCEPT</code></p><hr><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- UNION</span><span class="token comment" spellcheck="true">-- 查询计算机科学系的学生及年龄不大于19岁的学生。</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Sdept<span class="token operator">=</span><span class="token string">'CS'</span> <span class="token keyword">UNION</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Sage<span class="token operator">&lt;=</span><span class="token number">19</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Sdept<span class="token operator">=</span><span class="token string">'CS'</span> <span class="token operator">OR</span> Sage<span class="token operator">&lt;=</span><span class="token number">19</span><span class="token punctuation">;</span></code></pre><table><thead><tr><th align="center">Sno</th><th align="center">Sname</th><th align="center">Ssex</th><th align="center">Sage</th><th align="center">Sdept</th></tr></thead><tbody><tr><td align="center">200215121</td><td align="center">李勇</td><td align="center">男</td><td align="center">20</td><td align="center">CS</td></tr><tr><td align="center">200215122</td><td align="center">刘晨</td><td align="center">女</td><td align="center">19</td><td align="center">CS</td></tr><tr><td align="center">200215125</td><td align="center">张立</td><td align="center">男</td><td align="center">19</td><td align="center">IS</td></tr><tr><td align="center">200215126</td><td align="center">张红</td><td align="center">女</td><td align="center">19</td><td align="center">CS</td></tr></tbody></table><hr><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- UNION</span><span class="token comment" spellcheck="true">-- 查询选修了课程1或者选修了课程2的学生。</span><span class="token comment" spellcheck="true">-- 本例即查询选修课程1的学生集合与选修课程2的学生集合的并集</span><span class="token keyword">SELECT</span> Sno <span class="token keyword">FROM</span> SC <span class="token keyword">WHERE</span> Cno<span class="token operator">=</span><span class="token string">'1'</span> <span class="token keyword">UNION</span> <span class="token keyword">SELECT</span> Sno <span class="token keyword">FROM</span> SC <span class="token keyword">WHERE</span> Cno<span class="token operator">=</span><span class="token string">'2'</span><span class="token punctuation">;</span></code></pre><table><thead><tr><th align="center">Sno</th></tr></thead><tbody><tr><td align="center">200215121</td></tr><tr><td align="center">200215122</td></tr></tbody></table><hr><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--INTERSECT</span><span class="token comment" spellcheck="true">-- 查询计算机科学系的学生与年龄不大于19岁的学生的交集</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Sdept<span class="token operator">=</span><span class="token string">'CS'</span> <span class="token keyword">INTERSECT</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Sage<span class="token operator">&lt;=</span><span class="token number">19</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Sdept<span class="token operator">=</span><span class="token string">'CS'</span> <span class="token operator">AND</span> Sage<span class="token operator">&lt;=</span><span class="token number">19</span><span class="token punctuation">;</span></code></pre><table><thead><tr><th align="center">Sno</th><th align="center">Sname</th><th align="center">Ssex</th><th align="center">Sage</th><th align="center">Sdept</th></tr></thead><tbody><tr><td align="center">200215122</td><td align="center">刘晨</td><td align="center">女</td><td align="center">19</td><td align="center">CS</td></tr><tr><td align="center">200215126</td><td align="center">张红</td><td align="center">女</td><td align="center">19</td><td align="center">CS</td></tr></tbody></table><hr><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--INTERSECT</span><span class="token comment" spellcheck="true">-- 查询既选修了课程1又选修了课程2的学生。就是查询选修课程1的学生集合与选修课程2的学生集合的交集</span><span class="token keyword">SELECT</span> Sno <span class="token keyword">FROM</span> SC <span class="token keyword">WHERE</span> Cno<span class="token operator">=</span><span class="token string">'1'</span> <span class="token keyword">INTERSECT</span> <span class="token keyword">SELECT</span> Sno <span class="token keyword">FROM</span> SC <span class="token keyword">Where</span> Cno<span class="token operator">=</span><span class="token string">'2'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Sno <span class="token keyword">FROM</span> SC <span class="token keyword">WHERE</span> Cno<span class="token operator">=</span><span class="token string">'1'</span> <span class="token operator">AND</span> Sno <span class="token operator">IN</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> Sno <span class="token keyword">FROM</span> SC <span class="token keyword">WHERE</span> Cno<span class="token operator">=</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><table><thead><tr><th align="center">Sno</th></tr></thead><tbody><tr><td align="center">200215121</td></tr></tbody></table><hr><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--EXCEPT</span><span class="token comment" spellcheck="true">-- 查询计算机科学系的学生与年龄不大于19岁的学生的差集</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Sdept<span class="token operator">=</span><span class="token string">'CS'</span> <span class="token keyword">EXCEPT</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Sage<span class="token operator">&lt;=</span><span class="token number">19</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 也就是查询计算机科学系中年龄大于19岁的学生</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Sdept<span class="token operator">=</span><span class="token string">'CS'</span> <span class="token operator">AND</span> Sage<span class="token operator">></span><span class="token number">19</span><span class="token punctuation">;</span></code></pre><table><thead><tr><th align="center">Sno</th><th align="center">Sname</th><th align="center">Ssex</th><th align="center">Sage</th><th align="center">Sdept</th></tr></thead><tbody><tr><td align="center">200215121</td><td align="center">李勇</td><td align="center">男</td><td align="center">20</td><td align="center">CS</td></tr></tbody></table><hr><blockquote><p>数据库系统概论（第五版） 王珊 萨师煊</p></blockquote><blockquote><p>侵权必删</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线索二叉树和遍历</title>
      <link href="/2019/04/18/datastructthreadbintree/"/>
      <url>/2019/04/18/datastructthreadbintree/</url>
      
        <content type="html"><![CDATA[<h2 id="线索二叉树的基本概念"><a href="#线索二叉树的基本概念" class="headerlink" title="线索二叉树的基本概念"></a>线索二叉树的基本概念</h2><ul><li>二叉树的<strong>线索化</strong>指的是依照某种遍历次序使二叉树成为线索二叉树的过程。</li><li><strong>线索化</strong>的过程就是在遍历过程中<strong>修改</strong>空指针使其指向<strong>直接前驱</strong>或<strong>直接后继</strong>的过程。</li><li>设一棵二叉树有<code>n</code>个结点，则有<code>n-1</code>条边(指针连线) ， 而<code>n</code>个结点共有<code>2n</code>个指针域(<code>Lchild</code>和<code>Rchild</code>) ，显然有<code>n+1</code>个空闲指针域未用。则可以利用这些空闲的指针域来存放结点的直接前驱和直接后继信息。<ul><li>若结点有左孩子，则<code>Lchild</code>指向其左孩子，否则，指向其直接前驱；</li><li>若结点有右孩子，则<code>Rchild</code>指向其右孩子，否则，指向其直接后继；</li></ul></li></ul><p><img src="https://www.haczz.xyz/img/temp/DataStructTBT.png" alt=""></p><hr><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">char</span> TElemType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> BiThrNode<span class="token punctuation">{</span>    TElemType data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> BiThrNode <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 左右孩子指针</span>    <span class="token keyword">int</span> LTag<span class="token punctuation">,</span>RTag<span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">// 左右标志</span><span class="token punctuation">}</span>BiThrNode<span class="token punctuation">,</span><span class="token operator">*</span>BiThrTree<span class="token punctuation">;</span></code></pre><p>线索化二叉树比普通二叉树的存储结构多了<strong>左右孩子指针</strong>和<strong>左右标志</strong></p><h3 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">InThreading</span><span class="token punctuation">(</span>BiThrTree p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// pre是全局变量，初始化时其右孩子指针为空，便于在树的最左点开始建线索</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">InThreading</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 左子树递归线索化</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// p的左孩子为空 </span>            p<span class="token operator">-</span><span class="token operator">></span>LTag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            p<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token operator">=</span>pre<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// p的左孩子指向前驱 </span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            p<span class="token operator">-</span><span class="token operator">></span>LTag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>pre<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">{</span>            pre<span class="token operator">-</span><span class="token operator">></span>RTag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 给pre加上右线索 </span>            pre<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token operator">=</span>p<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// pre的右孩子指针指向p（后继） </span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            pre<span class="token operator">-</span><span class="token operator">></span>RTag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        pre<span class="token operator">=</span>p<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 保持pre指向p的前驱 </span>        <span class="token function">InThreading</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 右子树递归线索化 </span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><h3 id="带头结点的线索化二叉树"><a href="#带头结点的线索化二叉树" class="headerlink" title="带头结点的线索化二叉树"></a>带头结点的线索化二叉树</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">InOrderThreading</span><span class="token punctuation">(</span>BiThrTree <span class="token operator">&amp;</span>Thrt<span class="token punctuation">,</span>BiThrTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 中序遍历二叉树T，并将其中序线索化，Thrt指向头结点</span>    Thrt<span class="token operator">=</span><span class="token punctuation">(</span>BiThrTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiThrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 建立头结点 </span>    Thrt<span class="token operator">-</span><span class="token operator">></span>LTag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">// 头结点有左孩子，若树非空，则其左孩子为树根 </span>    Thrt<span class="token operator">-</span><span class="token operator">></span>RTag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">// 头结点的右孩子指针为右线索</span>    Thrt<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token operator">=</span>Thrt<span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">// 初始化时右指针指向自己</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span>        Thrt<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token operator">=</span>T<span class="token punctuation">;</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        Thrt<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token operator">=</span>T<span class="token punctuation">;</span>        pre<span class="token operator">=</span>Thrt<span class="token punctuation">;</span>        <span class="token function">InThreading</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>        pre<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token operator">=</span>Thrt<span class="token punctuation">;</span>        pre<span class="token operator">-</span><span class="token operator">></span>RTag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        Thrt<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token operator">=</span>pre<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 头结点的右线索    </span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> </code></pre><h3 id="遍历带头结点的线索化二叉树"><a href="#遍历带头结点的线索化二叉树" class="headerlink" title="遍历带头结点的线索化二叉树"></a>遍历带头结点的线索化二叉树</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*    * ①指针p指向根节点。    * ②p为非空树或遍历结束时，执行以下操作    *     * 沿左孩子向下，到达最左下结点*p,它是中序的第一个结点    *    * 访问*p    *    * 沿右线索反复查找当前结点*p的后继结点并访问后继结点，直至右线索为0或者遍历结束     *    * 转向p的右子树     */</span><span class="token keyword">void</span> <span class="token function">InOrderTraverse_Thr</span><span class="token punctuation">(</span>BiThrTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// T指向头结点，头结点的左链lchild指向根节点</span>        <span class="token comment" spellcheck="true">// 中序遍历二叉树线索树T的非递归算法，对每个数据元素直接输出</span>    BiThrTree p<span class="token operator">=</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>LTag<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>            p<span class="token operator">=</span>p<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span>p<span class="token operator">-</span><span class="token operator">></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>RTag<span class="token operator">==</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>p<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token operator">!=</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>            p<span class="token operator">=</span>p<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span>p<span class="token operator">-</span><span class="token operator">></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 沿着右线索访问后继结点 </span>        <span class="token punctuation">}</span>        p<span class="token operator">=</span>p<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 转向p的右子树 </span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>算法分析：遍历搜索二叉树的事件复杂度为O(n)，空间复杂度为O(1),这是因为线索二叉树的遍历不需要使用栈来实现递归操作</p><h3 id="在编程中遇见的问题"><a href="#在编程中遇见的问题" class="headerlink" title="在编程中遇见的问题"></a>在编程中遇见的问题</h3><ul><li>在写遍历中序线索二叉树的时候 <code>while(p-&gt;RTag==1&amp;&amp;p-&gt;lchild!=T){</code> 后边的条件写成了<code>p-&gt;lchild!=T</code>造成了一直循环</li><li>在<code>InOrderThreading</code>方法和<code>InThreading</code>的<code>pre</code>指针是一个全局变量，通过pre来临时存放前驱。</li></ul><h3 id="代码全貌"><a href="#代码全貌" class="headerlink" title="代码全貌"></a>代码全貌</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token comment" spellcheck="true">// - - - - 二叉树的二叉线索存储表示 - - - - </span><span class="token keyword">typedef</span> <span class="token keyword">char</span> TElemType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> BiThrNode<span class="token punctuation">{</span>    TElemType data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> BiThrNode <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 左右孩子指针</span>    <span class="token keyword">int</span> LTag<span class="token punctuation">,</span>RTag<span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">// 左右标志 </span><span class="token punctuation">}</span>BiThrNode<span class="token punctuation">,</span><span class="token operator">*</span>BiThrTree<span class="token punctuation">;</span> BiThrTree pre<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">InThreading</span><span class="token punctuation">(</span>BiThrTree p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// pre是全局变量，初始化时其右孩子指针为空，便于在树的最左点开始建线索</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">InThreading</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 左子树递归线索化</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// p的左孩子为空 </span>            p<span class="token operator">-</span><span class="token operator">></span>LTag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            p<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token operator">=</span>pre<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// p的左孩子指向前驱 </span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            p<span class="token operator">-</span><span class="token operator">></span>LTag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>pre<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">{</span>            pre<span class="token operator">-</span><span class="token operator">></span>RTag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 给pre加上右线索 </span>            pre<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token operator">=</span>p<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// pre的右孩子指针指向p（后继） </span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            pre<span class="token operator">-</span><span class="token operator">></span>RTag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        pre<span class="token operator">=</span>p<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 保持pre指向p的前驱 </span>        <span class="token function">InThreading</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 右子树递归线索化 </span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">InOrderThreading</span><span class="token punctuation">(</span>BiThrTree <span class="token operator">&amp;</span>Thrt<span class="token punctuation">,</span>BiThrTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 中序遍历二叉树T，并将其中序线索化，Thrt指向头结点</span>    Thrt<span class="token operator">=</span><span class="token punctuation">(</span>BiThrTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiThrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 建立头结点 </span>    Thrt<span class="token operator">-</span><span class="token operator">></span>LTag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">// 头结点有左孩子，若树非空，则其左孩子为树根 </span>    Thrt<span class="token operator">-</span><span class="token operator">></span>RTag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">// 头结点的右孩子指针为右线索</span>    Thrt<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token operator">=</span>Thrt<span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">// 初始化时右指针指向自己</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span>        Thrt<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token operator">=</span>T<span class="token punctuation">;</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        Thrt<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token operator">=</span>T<span class="token punctuation">;</span>        pre<span class="token operator">=</span>Thrt<span class="token punctuation">;</span>        <span class="token function">InThreading</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>        pre<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token operator">=</span>Thrt<span class="token punctuation">;</span>        pre<span class="token operator">-</span><span class="token operator">></span>RTag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        Thrt<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token operator">=</span>pre<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 头结点的右线索    </span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/*    * ①指针p指向根节点。    * ②p为非空树或遍历结束时，执行以下操作    *     * 沿左孩子向下，到达最左下结点*p,它是中序的第一个结点    *    * 访问*p    *    * 沿右线索反复查找当前结点*p的后继结点并访问后继结点，直至右线索为0或者遍历结束     *    * 转向p的右子树     */</span><span class="token keyword">void</span> <span class="token function">InOrderTraverse_Thr</span><span class="token punctuation">(</span>BiThrTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// T指向头结点，头结点的左链lchild指向根节点</span>        <span class="token comment" spellcheck="true">// 中序遍历二叉树线索树T的非递归算法，对每个数据元素直接输出</span>    BiThrTree p<span class="token operator">=</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>LTag<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>            p<span class="token operator">=</span>p<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span>p<span class="token operator">-</span><span class="token operator">></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>RTag<span class="token operator">==</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>p<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token operator">!=</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>            p<span class="token operator">=</span>p<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span>p<span class="token operator">-</span><span class="token operator">></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 沿着右线索访问后继结点 </span>        <span class="token punctuation">}</span>        p<span class="token operator">=</span>p<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 转向p的右子树 </span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">CreateBiTree</span><span class="token punctuation">(</span>BiThrTree <span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 按照次序输入二叉树结点的值（一个字符），创建二叉链表表示的二叉树T </span>    <span class="token keyword">char</span> ch<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ch<span class="token operator">==</span><span class="token string">'#'</span><span class="token punctuation">)</span>        T<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 递归结束，建空树</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        T<span class="token operator">=</span><span class="token punctuation">(</span>BiThrTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiThrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        T<span class="token operator">-</span><span class="token operator">></span>data<span class="token operator">=</span>ch<span class="token punctuation">;</span>        <span class="token function">CreateBiTree</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 递归创建左子树</span>        <span class="token function">CreateBiTree</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 递归创建右子树 </span>    <span class="token punctuation">}</span>                              <span class="token comment" spellcheck="true">// else </span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ABC##DE#G##F### 树的输入数据（通过递归）</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    BiThrTree bt<span class="token punctuation">,</span>thrt<span class="token punctuation">;</span>    pre<span class="token operator">=</span><span class="token punctuation">(</span>BiThrTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiThrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">CreateBiTree</span><span class="token punctuation">(</span>bt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">InOrderThreading</span><span class="token punctuation">(</span>thrt<span class="token punctuation">,</span>bt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">InOrderTraverse_Thr</span><span class="token punctuation">(</span>thrt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树、遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遍历二叉树以及常用方法</title>
      <link href="/2019/04/17/datastructbintree/"/>
      <url>/2019/04/17/datastructbintree/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><ul><li><strong>性质一</strong>：在二叉树的第$i$层上至多有$2^{i-1}$个结点$(i\geq1)$</li><li><strong>性质二</strong>：深度为$k$的二叉树至多有$2^k-1$个结点$(k\geq1)$</li><li><strong>性质三</strong>：对任何一棵二叉树$T$，如果其结点数为$n_0$，度为2的结点数为${n_2}$，则$n_0=n_2+1$</li><li><strong>性质四</strong>：具有$n$个结点的完全二叉树的深度为$\left \lfloor Log_2n \right \rfloor+1$</li><li><strong>性质五</strong>：如果对一棵有$n$个结点的完全二叉树的（其深度为$\left \lfloor Log_2n \right \rfloor+1$）的结点按层序编号（从第1层到第$\left \lfloor Log_2n \right \rfloor+1$，每层从左到右），则对任一结点$i(1\leq i\leq n)$，有<ul><li>如果$如果i=1$，则结点$i$是二叉树的根，无双亲；如果$i&gt;1$，则其双亲$PARENT(i)$是结点$\left \lfloor i/2 \right \rfloor$</li><li>如果$2i&gt;n$，则结点$i$无左孩子（结点$i$为叶子结点）；否则其左孩子$LCHILD(i)$是结点$2i$。</li><li>如果$2i+1&gt;n$，则结点$i$无右孩子；否则其右孩子$RCHILD(i)$是结点$2i+1$</li></ul></li></ul><p>三道例题</p><pre class=" language-txt"><code class="language-txt">1. 在一棵度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶结点个数为？（2010年真题）A 41        !B 82         C  113          D 1222. 已知一棵完全二叉树的第6层（根为第1层）有8个叶结点，则该完全二叉树的结点个数最多为？(   )  (2009年真题）A 39        B  52       !C  111     D 1193. 若一棵完全二叉树有768个结点，则该二叉树中叶子结点的个数为（）：   (2011年真题）A 257        B  258       C  384     D 385</code></pre><p><img src="DataStructTBDemo.jpg" alt="三道题演算过程"></p><h2 id="森林与二叉树的转换"><a href="#森林与二叉树的转换" class="headerlink" title="森林与二叉树的转换"></a>森林与二叉树的转换</h2><ol><li><p>森林转换称二叉树<br>如果$F=(T_1,T_2,…,T_m)$是森林，则可按如下规则转换成一棵二叉树$B=(root,LB,RB)$。<br>（1）若$F$为空，则$m=0$，则$B$为空树；<br>（2）若$F$非空，即$m\ne0$，则$B$的根$root$即为森林中第一棵树的根$ROOT(T_1)$；$B$的左子树LB是从$T_1$中根结点的子树森林$F_1={T_{11},T_{12},…,T_{1m}}$</p></li><li><p>二叉树转换成森林<br>如果$B=(root,LB,RB)$是一棵二叉树，则可按如下规则转换成森林$F={T_1,T_2,…,T_m}$;<br>(1)若$B$为空，则$F$为空；<br>(2)若$B$非空，则$F$中的第一颗树$T_1$的根$ROOT(T_1)$即为二叉树$B$的根$root$是，$T_1$中根节点的子树$F_1$是由$B$的左子树$LB$转换而成的森林；$F$中除了$T_1$之外其余树组成的森林$F^{‘}={T_2,T_3,…,T_m}$是由B的右子树$RB$转换而成的森林</p></li></ol><h2 id="树的概念-附"><a href="#树的概念-附" class="headerlink" title="树的概念[附]"></a>树的概念[附]</h2><p>树结构是一类重要的非线性结构。树型结构是结点之间有分支，并且具有层次关系的结构。<br>树是<code>n(n&gt;=0)</code>个结点的有限集，它或为空树<code>n=0</code>;或为非空树：<br>（1）有且仅有一个称之为根的结点；<br>（2）除根结点以外的其余结点可分为<code>m（m&gt;0）</code>个互不相交的有限集$T_1,T_2,T_3,…,T_m$，其中每一个集合又是一棵树，并且称为子树<code>(SubTree)</code></p><center><b>树是递归数据结构：树的定义中引用了树概念本身</b></center><h2 id="树-二叉树的数据结构"><a href="#树-二叉树的数据结构" class="headerlink" title="树/二叉树的数据结构"></a>树/二叉树的数据结构</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> BiTNode<span class="token punctuation">{</span>    TElemType data<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 结点数据域</span>    <span class="token keyword">struct</span> BiTNode <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 左右孩子指针</span><span class="token punctuation">}</span>BiTNode<span class="token punctuation">,</span><span class="token operator">*</span>BiTree<span class="token punctuation">;</span></code></pre><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><ul><li>前序遍历</li><li>中序遍历</li><li>后续遍历</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 中序遍历二叉树T的递归算法</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 若二叉树非空</span>        <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 中序遍历左子树</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span>T<span class="token operator">-</span><span class="token operator">></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 访问根结点</span>        <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 中序遍历右子树</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 前序遍历二叉树T的递归算法</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 若二叉树非空</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span>T<span class="token operator">-</span><span class="token operator">></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 访问根结点</span>        <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前序遍历左子树</span>        <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前序序遍历右子树</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">PostOrderTraverse</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 后续遍历二叉树T的递归算法</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 若二叉树非空</span>        <span class="token function">PostOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 后续遍历左子树</span>        <span class="token function">PostOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 后续遍历右子树</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span>T<span class="token operator">-</span><span class="token operator">></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 访问根结点</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">Depth</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 计算二叉树的T的深度</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> m<span class="token operator">=</span><span class="token function">Depth</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n<span class="token operator">=</span><span class="token function">Depth</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>m<span class="token operator">></span>n<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="二叉树结点数量"><a href="#二叉树结点数量" class="headerlink" title="二叉树结点数量"></a>二叉树结点数量</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">NodeCount</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 统计二叉树T中结点的个数</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果是空树，则结点个数为0，递归结束</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token function">NodeCount</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">NodeCount</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="二叉树非递归算法"><a href="#二叉树非递归算法" class="headerlink" title="二叉树非递归算法"></a>二叉树非递归算法</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">InOrderTraverse_rc</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 中序遍历二叉树T的非递归算法</span>    SqStack S<span class="token punctuation">;</span>    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>    BiTree p<span class="token operator">=</span>T<span class="token punctuation">,</span>q<span class="token operator">=</span><span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">||</span><span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// p为空</span>            <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>            p<span class="token operator">=</span>p<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 退栈</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span>q<span class="token operator">-</span><span class="token operator">></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 访问根结点</span>            p<span class="token operator">=</span>q<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 遍历右子树</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="复制二叉树"><a href="#复制二叉树" class="headerlink" title="复制二叉树"></a>复制二叉树</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Copy</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">,</span>BiTree <span class="token operator">&amp;</span>NewT<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 复制一颗和T完全相同的二叉树</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">// 如果是空树，递归结束 </span>        NewT<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        NewT<span class="token operator">=</span><span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        NewT<span class="token operator">-</span><span class="token operator">></span>data<span class="token operator">=</span>T<span class="token operator">-</span><span class="token operator">></span>data<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 复制根结点 </span>        <span class="token function">Copy</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">,</span>NewT<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 递归复制左子树 </span>        <span class="token function">Copy</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">,</span>NewT<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 递归复制右子树 </span>    <span class="token punctuation">}</span>                                    <span class="token comment" spellcheck="true">// else </span><span class="token punctuation">}</span> </code></pre><h2 id="在遍历二叉树的时候遇到的问题"><a href="#在遍历二叉树的时候遇到的问题" class="headerlink" title="在遍历二叉树的时候遇到的问题"></a>在遍历二叉树的时候遇到的问题</h2><ul><li>中序遍历二叉树T的非递归算法中用到了栈，栈如何定义？</li><li>写<code>Copy</code>方法的时候，出现了<code>Program received signal SIGSEGV, Segmentation fault</code>错误。</li><li><font color="red">第一个出现问题的解决办法代码</font></li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">InitStack</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建一个空栈</span>    S<span class="token punctuation">.</span>base<span class="token operator">=</span><span class="token punctuation">(</span>BiTree<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token operator">*</span>MAXSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// BiTree 是一个指针，要建立一个存放指针的数组</span>    <span class="token comment" spellcheck="true">// (指针的指针)malloc(sizeof(指针)*MAXSIZE);</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>S<span class="token punctuation">.</span>base<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    S<span class="token punctuation">.</span>top<span class="token operator">=</span>S<span class="token punctuation">.</span>base<span class="token punctuation">;</span>    S<span class="token punctuation">.</span>stacksize<span class="token operator">=</span>MAXSIZE<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span> </code></pre><p>也就是说需要动态分配一个存放指针的数组，而指向这个数组也是一个指针<br>所以是</p><pre class=" language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>指针的指针<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>指针<span class="token punctuation">)</span><span class="token operator">*</span>MAXSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><font color="red">第二个出现问题的解决办法</font></li></ul><p><code>Program received signal SIGSEGV, Segmentation fault</code>这句话翻译过来是程序接受了一个<code>SIGSEGV</code>的标志，分割失败，说白了就是某个地方的值越界了，后来仔细看看原来是<code>if(T=NULL)</code>少了一个等号</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Copy</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">,</span>BiTree <span class="token operator">&amp;</span>NewT<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 复制一颗和T完全相同的二叉树</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 少了一个等号</span>        NewT<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        NewT<span class="token operator">=</span><span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        NewT<span class="token operator">-</span><span class="token operator">></span>data<span class="token operator">=</span>T<span class="token operator">-</span><span class="token operator">></span>data<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 复制根结点</span>        <span class="token function">Copy</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">,</span>NewT<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 递归复制左子树</span>        <span class="token function">Copy</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">,</span>NewT<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 递归复制右子树</span>    <span class="token punctuation">}</span>                                    <span class="token comment" spellcheck="true">// else</span><span class="token punctuation">}</span></code></pre><p>完整代码贴出</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> MAXSIZE 100</span><span class="token comment" spellcheck="true">// - - - - 二叉树的二叉链表存储表示 - - - -</span><span class="token keyword">typedef</span> <span class="token keyword">char</span> TElemType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> BiTNode<span class="token punctuation">{</span>    TElemType data<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 结点数据域</span>    <span class="token keyword">struct</span> BiTNode <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 左右孩子指针  </span><span class="token punctuation">}</span>BiTNode<span class="token punctuation">,</span><span class="token operator">*</span>BiTree<span class="token punctuation">;</span> <span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    BiTree <span class="token operator">*</span>base<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 栈底指针 </span>    BiTree <span class="token operator">*</span>top<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 栈顶指针 </span>    <span class="token keyword">int</span> stacksize<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 栈可用的最大容量 </span><span class="token punctuation">}</span>SqStack<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">InitStack</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建一个空栈 </span>    S<span class="token punctuation">.</span>base<span class="token operator">=</span><span class="token punctuation">(</span>BiTree<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token operator">*</span>MAXSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// BiTree 是一个指针，要建立一个存放指针的数组</span>    <span class="token comment" spellcheck="true">// (指针的指针)malloc(sizeof(指针)*MAXSIZE);</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>S<span class="token punctuation">.</span>base<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    S<span class="token punctuation">.</span>top<span class="token operator">=</span>S<span class="token punctuation">.</span>base<span class="token punctuation">;</span>    S<span class="token punctuation">.</span>stacksize<span class="token operator">=</span>MAXSIZE<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">Push</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">,</span>BiTree bt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top<span class="token operator">-</span>S<span class="token punctuation">.</span>base<span class="token operator">==</span>S<span class="token punctuation">.</span>stacksize<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token operator">*</span>S<span class="token punctuation">.</span>top<span class="token operator">++</span><span class="token operator">=</span>bt<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">Pop</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">,</span>BiTree <span class="token operator">&amp;</span>bt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 删除S的栈顶元素，用e返回其值</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top<span class="token operator">==</span>S<span class="token punctuation">.</span>base<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    bt<span class="token operator">=</span><span class="token operator">*</span><span class="token operator">--</span>S<span class="token punctuation">.</span>top<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">StackEmpty</span><span class="token punctuation">(</span>SqStack S<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top<span class="token operator">==</span>S<span class="token punctuation">.</span>base<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* ①扫描字符序列，读入字符ch     * ②如果ch是一个"#"字符，则表明该二叉树为空树，即T为NULL；否则执行以下操作     *         # 申请一个结点空间T     *      # 将ch赋给T->data    *        # 递归创建T的左子树    *        # 递归创建T的右子树      */</span><span class="token keyword">void</span> <span class="token function">CreateBiTree</span><span class="token punctuation">(</span>BiTree <span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 按先后次序输入二叉树中结点的值（一个字符），创建二叉链表表示二叉树T</span>    <span class="token keyword">char</span> ch<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ch<span class="token operator">==</span><span class="token string">'#'</span><span class="token punctuation">)</span>         T<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>        T<span class="token operator">=</span><span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 生成根节点</span>        T<span class="token operator">-</span><span class="token operator">></span>data<span class="token operator">=</span>ch<span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">// 根结点数据域置为ch</span>        <span class="token function">CreateBiTree</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 递归创建左子树</span>        <span class="token function">CreateBiTree</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 递归创建右子树 </span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 中序遍历二叉树T的递归算法</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 若二叉树非空</span>        <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 中序遍历左子树 </span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span>T<span class="token operator">-</span><span class="token operator">></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 访问根结点 </span>        <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 中序遍历右子树         </span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 前序遍历二叉树T的递归算法</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 若二叉树非空</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span>T<span class="token operator">-</span><span class="token operator">></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 访问根结点 </span>        <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前序遍历左子树 </span>        <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前序序遍历右子树         </span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">PostOrderTraverse</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 后续遍历二叉树T的递归算法</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 若二叉树非空 </span>        <span class="token function">PostOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 后续遍历左子树 </span>        <span class="token function">PostOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 后续遍历右子树 </span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span>T<span class="token operator">-</span><span class="token operator">></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 访问根结点 </span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/*    * 如果是空树，递归结束，深度为0，否则执行以下操作：    *         # 递归计算左子树的深度记为m     *        # 递归计算右子树的深度记为n    *        # 如果m大于n，二叉树的深度为m+1，否则为n+1     */</span><span class="token keyword">int</span> <span class="token function">Depth</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 计算二叉树的T的深度</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> m<span class="token operator">=</span><span class="token function">Depth</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n<span class="token operator">=</span><span class="token function">Depth</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>m<span class="token operator">></span>n<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">NodeCount</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 统计二叉树T中结点的个数</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果是空树，则结点个数为0，递归结束</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token function">NodeCount</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">NodeCount</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">InOrderTraverse_rc</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 中序遍历二叉树T的非递归算法</span>    SqStack S<span class="token punctuation">;</span>    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>    BiTree p<span class="token operator">=</span>T<span class="token punctuation">,</span>q<span class="token operator">=</span><span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">||</span><span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// p非空 </span>            <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>            p<span class="token operator">=</span>p<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 退栈</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span>q<span class="token operator">-</span><span class="token operator">></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 访问根结点 </span>            p<span class="token operator">=</span>q<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 遍历右子树 </span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 如果是空树，递归结束，否则执行以下操作</span><span class="token comment" spellcheck="true">//  # 申请一个新结点空间，复制根结点；</span><span class="token comment" spellcheck="true">//  # 递归复制左子树。 </span><span class="token comment" spellcheck="true">//  # 递归复制右子树。</span><span class="token keyword">void</span> <span class="token function">Copy</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">,</span>BiTree <span class="token operator">&amp;</span>NewT<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 复制一颗和T完全相同的二叉树</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">// 如果是空树，递归结束 </span>        NewT<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        NewT<span class="token operator">=</span><span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        printf("%c %c",NewT->data,T->data);</span>        NewT<span class="token operator">-</span><span class="token operator">></span>data<span class="token operator">=</span>T<span class="token operator">-</span><span class="token operator">></span>data<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 复制根结点 </span>        <span class="token function">Copy</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">,</span>NewT<span class="token operator">-</span><span class="token operator">></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 递归复制左子树 </span>        <span class="token function">Copy</span><span class="token punctuation">(</span>T<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">,</span>NewT<span class="token operator">-</span><span class="token operator">></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 递归复制右子树 </span>    <span class="token punctuation">}</span>                                    <span class="token comment" spellcheck="true">// else </span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// ABC##DE#G##F### 树的输入数据（通过递归） </span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    BiTree bt<span class="token punctuation">,</span>newBt<span class="token punctuation">;</span>    <span class="token function">CreateBiTree</span><span class="token punctuation">(</span>bt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"后序遍历的结果是："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">InOrderTraverse_rc</span><span class="token punctuation">(</span>bt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n树的深度为：%d"</span><span class="token punctuation">,</span><span class="token function">Depth</span><span class="token punctuation">(</span>bt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n树的结点个数为：%d"</span><span class="token punctuation">,</span><span class="token function">NodeCount</span><span class="token punctuation">(</span>bt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// --------------------</span>    <span class="token function">Copy</span><span class="token punctuation">(</span>bt<span class="token punctuation">,</span>newBt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">InOrderTraverse_rc</span><span class="token punctuation">(</span>newBt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树、遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高阶函数</title>
      <link href="/2015/07/31/javascriptadvancedfx/"/>
      <url>/2015/07/31/javascriptadvancedfx/</url>
      
        <content type="html"><![CDATA[<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数英文叫Higher-order function。那么什么是高阶函数？</p><p>JavaScript的函数其实都是指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p><p>一个最简单的高阶函数</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>f<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当我们调用<code>add(-5,6,Math.abs)</code>时，参数x,y,f分别接收<code>-5</code>,<code>6</code>和函数<code>Math.abs</code>，根据函数定义，我们可以推导计算过程</p><pre class=" language-javascript"><code class="language-javascript">x <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">;</span>y <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>f <span class="token operator">=</span> Math<span class="token punctuation">.</span>abs<span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">></span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">></span> <span class="token number">11</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">11</span><span class="token punctuation">;</span></code></pre><p>用代码验证一下:</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span>Math<span class="token punctuation">.</span>abs<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 11</span></code></pre><p>编写高级函数，就是让函数的参数能够接收别的函数</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
